* Preamble :ignore:
:PROPERTIES:
:CUSTOM_ID: Preamble
:END:

# NOTE: Press ‚ÄúC-c C-c‚Äù on a Rust snippet to run it.

#+export_file_name: index.html
# blog:header
#+html_head: <link href="https://alhassy.github.io/org-notes-style.css" rel="stylesheet" type="text/css" />
#+html_head: <link href="https://alhassy.github.io/floating-toc.css" rel="stylesheet" type="text/css" />
#+toc: headlines 2

#+title: Rust CheatSheet
# +SUBTITLE: ---Incomplete Draft---
#+macro: blurb A reference for Rust TODO
#+author: [[https://alhassy.github.io/][Musa Al-hassy]]
#+email: alhassy@gmail.com
# +TODO: Todo | spacing LaTeX
# +INCLUDE: ~/CheatSheet/CheatSheetSetup.org
# +OPTIONS: broken-links:auto toc:nil
# let's always break newlines, with a ‚Äò‚Ü™‚Äô indicated new lines.
#+LaTeX: \setminted[html]{fontsize=\footnotesize, breaklines}
#+latex_header: \usepackage{newunicodechar}
#+latex_header: \newunicodechar{‚ãØ}{\ensuremath{\cdots}}
#+latex_header: \newunicodechar{ùí≥}{\ensuremath{\mathcal{X}}}
#+latex_header: \newunicodechar{ùí¥}{\ensuremath{\mathcal{Y}}}
#+latex_header: \newunicodechar{‚ü©}{\ensuremath{\mathcal{\langle}}}
#+latex_header: \newunicodechar{‚ü®}{\ensuremath{\mathcal{\rangle}}}
#+latex_header: \newunicodechar{‚áí}{\ensuremath{\mathcal{\Rightarrow}}}
#+latex_header: \newunicodechar{‚Äú}{``}
#+latex_header: \newunicodechar{‚Äù}{''}

#+latex_header: \usepackage{MnSymbol,wasysym}
#+latex_header: \newunicodechar{üòª}{\smiley{}}

# (maybe-clone "https://github.com/armkeh/unicode-sty.git")
#+LATEX_HEADER: \usepackage{\string~"/unicode-sty/unicode"}

#+property: header-args:rust  :tangle rust-cheat-sheat.rs :exports code

* COMMENT Run
:PROPERTIES:
:CUSTOM_ID: COMMENT-Run
:END:

# ("" "titletoc" nil) ‚áí causes problems!
# (pop org-latex-default-packages-alist)

* TODO COMMENT Emacs Setup                                                   :ignore:
:PROPERTIES:
:CUSTOM_ID: COMMENT-Emacs-Setup
:END:

;; To investigate
;; https://github.com/grafov/rust-playground


;; started from http://emacs-bootstrap.com/

;; rust-mode
;; https://github.com/rust-lang/rust-mode

(use-package rust-mode
  :bind ( :map rust-mode-map
               (("C-c C-t" . racer-describe)
                ([?\t] .  company-indent-or-complete-common)))
  :config
  (progn
    ;; add flycheck support for rust (reads in cargo stuff)
    ;; https://github.com/flycheck/flycheck-rust
    (use-package flycheck-rust)

    ;; cargo-mode for all the cargo related operations
    ;; https://github.com/kwrooijen/cargo.el
    (use-package cargo
      :hook (rust-mode . cargo-minor-mode)
      :bind
      ("C-c C-c C-n" . cargo-process-new)) ;; global binding

    ;;; separedit ;; via https://github.com/twlz0ne/separedit.el
    (when nil use-package separedit
      :straight (separedit :type git :host github :repo "idcrook/separedit.el")
      :config
      (progn
        (define-key prog-mode-map (kbd "C-c '") #'separedit)
        (setq separedit-default-mode 'markdown-mode)))


        ;; TODO:NICE!
    ;;; racer-mode for getting IDE like features for rust-mode
    ;; https://github.com/racer-rust/emacs-racer
    (use-package racer
      :hook (rust-mode . racer-mode)
      :config
      (progn
        ;; package does this by default ;; set racer rust source path environment variable
        ;; (setq racer-rust-src-path (getenv "RUST_SRC_PATH"))
        (defun my-racer-mode-hook ()
          (set (make-local-variable 'company-backends)
               '((company-capf company-files)))
          (setq company-minimum-prefix-length 1)
          (setq indent-tabs-mode nil))

        (add-hook 'racer-mode-hook 'my-racer-mode-hook)

        ;; enable company and eldoc minor modes in rust-mode (racer-mode)
        (add-hook 'racer-mode-hook #'company-mode)
        (add-hook 'racer-mode-hook #'eldoc-mode)))

    (add-hook 'rust-mode-hook 'flycheck-mode)
    (add-hook 'flycheck-mode-hook 'flycheck-rust-setup)

    ;; format rust buffers on save using rustfmt
    (add-hook 'before-save-hook
              (lambda ()
                (when (eq major-mode 'rust-mode)
                  (rust-format-buffer))))))

)

#+end_src

#+RESULTS:

#+begin_src rust :exports none
fn main() {
    let x = 42;
    println!("{0}, this is {1}.", x, "bye");
}
#+end_src

#+RESULTS:
: 42, this is bye.

* Hello World!
:PROPERTIES:
:CUSTOM_ID: hello-world
:END:

  #+latex: {\color{white}.}

  #+latex: \vspace{-2.5em}
  #+begin_parallel 2

#+begin_src rust :tangle hello_world.rs
fn main() {
    println!("Hello, world!");
}
#+end_src


#+columnbreak:

Compile and run this with \\
src_emacs-lisp[:exports code]{rustc hello_world.rs; ./hello_world}
#+end_parallel

The src_emacs-lisp[:exports code]{main} function is special: It is always the first code that runs in
every program.  For now, know that names ending in src_emacs-lisp[:exports code]{!} are ‚Äúmacros‚Äù
---special functions that transform code.

** ~cargo new~
:PROPERTIES:
:CUSTOM_ID: cargo-new
:END:

Packages of code are referred to as [[https://crates.io/][/crates/]] ---which are shipped with /cargo/,
the build tool and package manager. Cargo is the most convenient way to create a
new Rust project.

# The new command takes the name of a project. Once we execute it, we'll see that
# it has generated a bunch of files including a Git repository, a ~src~ directory
# and a ~Cargo.toml~ file.

Running ~cargo new my-first-program~ creates a folder ~my-first-program~ with a
bunch of stuff in it. Importantly, it has a ~src/main.rs~ file which is our entry
point (which prints ‚ÄòHello, world!‚Äô) and ~Cargo.toml~ which is a configurations
file ---e.g., to keep track of what external packages our program requires. We
can now do ~cd my-first-program; cargo run~ to compile and run our program in one
go: ~Hello, world!~ is printed.

To install a new crate, simply add it to the end of the ~[dependencies]~ list in
~Cargo.toml~. For example, open ~Cargo.toml~ and [[https://crates.io/crates/rand][at the very end, add]] ~rand =
"0.8.5"~.  Next time you do =cargo run= it will install the ~rng~ randomness package.

# The Cargo file is a package file that specifies the name of the project, its
# version, the author's name and its email address and the edition or version of
# the Rust programming language. Additionally, we can specify other configuration
# values such as dependencies or dev-dependencies.

** Let's see a full program viz a Number Guessing Game
:PROPERTIES:
:CUSTOM_ID: Let's-see-a-full-program-viz-a-Number-Guessing-Game
:END:

#+latex: \newline
# Let's see a full program viz a Number Guessing Game:

#+latex: \vspace{-.5em}
#+ATTR_LATEX: :options fontsize=\scriptsize

# Run ~cargo new game; cd game; cargo install rng~ to make a new project and install

# Then place the following code in ~main.rs~ and run it with ~cargo run~.

#+begin_src rust
use std::io;   // Use the standard input-output library
use rand::Rng; // Use Random Number Generator trait, needs ‚Äúrand‚Äù crate
use std::cmp::Ordering; // Enumeration to denote result of comparisons

fn main() {
    println!("Guess the number!");
    // Ranges ‚Äúm..n‚Äù are all integers i with m ‚â§ i < n.
    let secret_number = rand::thread_rng().gen_range(1..101);

    // The ‚Äúloop‚Äù keyword creates an infinite loop.
    loop {
        println!("Please input your guess.");

        // ‚Äúmut‚Äùable variable, bound to an empty String object
        let mut guess = String::new();

        // Get a handle to the standard input for your terminal.
        // Then, stick user input into (a mutable reference to) ‚Äúguess‚Äù.
        // If something goes wrong, show an informative message.
        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        // Instead of ‚Äúexpect‚Äù, we can use ‚Äúmatch‚Äù to move from
        // crashing on an error to instead handling the error...

        /* Shadow the ‚Äúguess‚Äù variable to avoid using a new variable name.

           Handle the possibility of parse errors using Pattern Matching:
           We try to make an unsigned integer out of the user's string input;
           if no number is parsed, we ask the user to guess again. */
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_)  => continue // Restarts the loop
        };
        // Alternatively: guess.trim().parse().unwrap() tries to get ‚Äúnum‚Äù; otherwise it crashes.
        // ‚Äúunwrap‚Äù and ‚Äúexpect‚Äù are useful for quick development, but otherwise dangerous to use.

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => { println!("You win!"); break }, // Exit the loop
        }
    }
}
#+end_src

*Shadowing* (overriding) let's us /reuse/ names: Mutable variables can change their
value /only/, whereas shadowing means we can change the value /and/ the type.
Shadowing is done with src_rust[:exports code]{let}, whereas mutable variables can be assigned to
directly.
- With shadowing, src_rust[:exports code]{let x = f(x)}, we can perform a few transformations on a
  value but have the variable be immutable after those transformations have been
  completed.
  # The other difference between mut and shadowing is that because we‚Äôre effectively
  # creating a new variable when we use the let keyword again, we can change the
  # type of the value but reuse the same name.
:Declarations:

Bindings are immutable by default, which means their values can't be changed;
use src_rust[:exports code]{mut} to allow changes.

#+begin_src rust
fn main() {
    let _x     = 10;
    let y: i32 = 20; // With explicit type anotation (integer 32-bit)
    let y      = 'a'; // ‚ÄòShadow‚Äô y
    let mut z  = 12; // A mutable (changeable) variable
    z = 13;
    let _ = println!("{0} and {1}", y, z); // Ignore result
}
#+end_src

# Unused bindings are likely an error, so the compiler warns about them ---/unless/
# a name starts with an underscore.
:End:

The src_rust[:exports code]{parse} function returns a value of type ~Option~, which might contain
something or it might not contain anything. (Akin to type-safe nullables).

/Exercise!/ Instead of the src_rust[:exports code]{continue} on parse errors, src_rust[:exports code]{use std:process} library
to quit the program with src_rust[:exports code]{process::exit(1)} after providing a useful message to
the user.

/Exercise!/ Instead of the src_rust[:exports code]{continue} on parse errors, quit the program with
~panic!("Not a number")~ ---this violently stops execution with an error message,
source file name, and line number. (Likewise, ~unwrap~ panics where there is no
~Option~ value to retrieve.)

/Exercise!/ Notice that the first src_emacs-lisp[:exports code]{guess} variable had its /string/ type
inferred.  If we remove the explicit /numeric/ type annotation from the second
src_emacs-lisp[:exports code]{guess} then src_emacs-lisp[:exports code]{parse} wouldn't know what kind
of value is being parsed and we get a compile error. Remove the explicit type
annotation by specialising src_emacs-lisp[:exports code]{parse} to get /numeric/ ~u32~ values using the
so-called ‚Äúturbofixh syntax‚Äù: src_rust[:exports code]{ parse::<u32>() }.

* Formatted text:  src_rust[:exports code]{format!, println!, dbg!}
:PROPERTIES:
:CUSTOM_ID: COMMENT-Formatted-text-print
:END:

We can write formatted text to a src_rust[:exports code]{String} object using
src_rust[:exports code]{format!} ---or print it to the console instead using
src_rust[:exports code]{println!}; both work the same and stringify their arguments.

# src_rust[:exports code]{ format! } is the same as src_rust[:exports code]{
# println! } but it makes a formatted text as a src_rust[:exports code]{ String }
# value.

Let's print /4 weeks and 31 days/ a few different ways:
#+begin_src rust
fn main() {
    // Placeholders `{}` will be replaced with arguments.
    println!("{} weeks and {} days", 4, 31);
    // Or using ‚Äúformat!‚Äù first.
    let it = format!("{} weeks and {} days", 4, 31);
    println!("{}", it);

    // Positional placeholders can be used.
    println!("{1} weeks and {0} days", 31, 4);

    // As can named arguments.
    println!("{all} weeks and {every} days", every = 31, all = 4);

    // We can mix and match.
    println!("{:?} weeks {1:?} {all} days", 4, "and", all = 31);

    // We can also ‚Äúpretty print‚Äù expressions; useful for lots of data
    println!("{:#?}", ["4", "weeks", "and", "31", "days"]);

    // We can see an expression, its value, and its location in code.
    dbg!(it); // Prints: [src/main.rs:19] it = "4 weeks and 31 days"
    let n = dbg!(1 * 2 + 3) - 1; // Prints: [src/main.rs:20] 1 * 2 + 3 = 5
    assert!(n == 4);

    // Sometimes it may be useful to see the memory address of a variable.
    println!("{:p}", &n);
}
#+end_src

#+RESULTS:
#+begin_example
4 weeks and 31 days
4 weeks and 31 days
4 weeks and 31 days
4 weeks and 31 days
4 weeks "and" 31 days
[
    "4",
    "weeks",
    "and",
    "31",
    "days",
]
[src/main.rs:22] it = "4 weeks and 31 days"
[src/main.rs:23] 1 * 2 + 3 = 5
0x7ffeeefacd70
#+end_example

Notice that the ~{:?}~ placeholder prints text for debugging purposes; e.g.,
strings keep their quotes. Alternatively, the src_ruby[:exports code]{dbg!}
macro takes ownership of an expression, prints the file and line number of where
that ~dbg!~ call occurs along with the resulting value of that expression, and
returns ownership of the value ---this means that /almost anywhere/ there is an
expression ùí≥, we can just replace it with ~dbg!(ùí≥)~ to get some useful debugging
information about it!
/The ~dbg!~ macro can be really helpful when you‚Äôre trying to figure out what your code is doing!/
- If you're doing lots of ~println!~ just to see values of variables/expressions,
  just use ~dbg!~ instead: ~println!("x = {}, y = {}", x, y)~ can be replaced by
  ~dbg!(x, y)~.

* The ‚Äú::‚Äù Notation: Types as Namespaces and General Imports
:PROPERTIES:
:CUSTOM_ID: the-notation-types-as-namespaces-and-general-imports
:END:

Dots are generally used to get field from an object such as ~p.0~ for pairs; the
double-colon is used similarly but for namespaces as in ~library::file::function~.
# scope resolution operator

# In this example, std is a crate (~ a library), cmp is a module (~ a source file), and min is a function: //
# let least = std::cmp::min(3, 8);                                                                         //


#+begin_src rust
fn main() {
    assert!(std::cmp::min(3, 8) == 3);
}
#+end_src

+ src_rust[:exports code]{use} directives can be used to ‚Äúbring into scope‚Äù names from other namespaces.
   #+begin_src rust
// use std::cmp::min;        // Single import
// use std::cmp::{max, min}; // Multiple imports
use std::cmp::*;             // Imports everything
fn main() {
    assert!(min(5, 5) == max(5, 5));
}
#+end_src

+ Types are namespaces too, and methods can be called as regular functions:
   #+begin_src rust
fn main() {
    assert!("hola".len() == str::len("hola"));
}
#+end_src
  In-general, ~object.method(args) ‚â° type::method(object, args)~.
* A First look at Ownership: Why ~let x = ‚ãØ; f(x); f(x)~ crashes
:PROPERTIES:
:CUSTOM_ID: a-first-look-at-ownership-why-let-x-f-x-f-x-crashes
:END:
# Understanding basic Ownership and Borrowing in Rust

# NOTE: Ownership and borrowing are so important to Rust, might as well get an
# early glimpse. If anything it sets the stage for the ‚ÄúTypes‚Äù section below.

Many languages distinguish between ‚Äòliterals‚Äô and ‚Äòobjects‚Äô, Rust does so with a
feature called /ownership/, which aims to prevent us from writing memory unsafe
code.

The following program looks like it should work without any problems...
#+begin_src rust -r -n
fn main() {
    let mut hi = "hello".to_string(); // We want an object; not a literal primitive. (ref:hi-def)

    fn speak(words: String) {
        println!("{}", words)
    }

    speak(hi); (ref:first-call)
    // speak(hi); // Whoops, the *value* of ‚Äúme‚Äù has moved out of this *variable*! (ref:second-call)

    hi = "yup".to_string(); (ref:all-good)
    speak(hi)
}
#+end_src

#+RESULTS:
: hello
: yup

*Ownership* means /variables own their values/:
+ Line [[(hi-def)]]: The variable ~hi~ owns the string value ~"hello~."
+ Line [[(first-call)]]: The value ~"hello"~ is passed into the function ~speak~, and so
  /ownership of the value has moved/. In-particular, ~hi~ no longer owns a value and
  so cannot be /accessed/ after this line.
+ Line [[(second-call)]]: We try to call the function ~speak~ with a variable that has
  no value and so we get a /compile-time/ error.
+ Line [[(all-good)]]: We can fix this by letting the variable ~hi~ /own/ a value,
  then we can use it again.

If we do need access to a variable's value in multiple function calls, we will
have to pass it by /reference/ instead of by value.

#+begin_src rust -r -n
fn main() {
    let mut hi = "hello".to_string();

    fn speak(words: &String) { (ref:borrow)
        println!("{}", words)
    }

    speak(&hi);  // Works first time. (ref:use)
    speak(&hi);  // Works second time!
}
#+end_src

#+RESULTS:
: hello
: hello

*Borrowing* means /temporarily owning something/: Line [[(borrow)]] says this function
wants a /reference/ to a string value; then line [[(use)]] calls the function by
making a reference using the ‚Äúborrow operator‚Äù ~&~.

+ A *reference* is a type that references another value in memory.
   # - They are created using the ‚Äúborrow operator‚Äù ~&~.
  - They're useful when we don't want to pass ‚Äúownership‚Äù to control structures
    (such as for-loops) or functions.
   :References_mwe:
#+begin_src rust
fn main() {
    let mut x = 12; // :      i32
    let r = &mut x; // : &mut i32

    *r = 45;
    assert_eq!(x, 45);
}
#+end_src

#+RESULTS:

:end:

+ A variable binding can be immutably borrowed multiple times:
  - ü•≥ ~let x = 1; let ref1 = &x; let ref2 = &x~.
  :Full_code:
  #+begin_src rust
fn main() {
    let x = 42;
    let x_ref1 = &x;
    let x_ref2 = &x;
    let x_ref3 = &x;
    println!("{} {} {}", x_ref1, x_ref2, x_ref3);
    assert!((x, x_ref1, x_ref2) == (42, &42, &42))
}
#+end_src
  :end:

+ While borrowed, a variable binding cannot be mutated:
  - üò¶ ~let mut x = 1; let ref = &x; x = 2~
  :full-code:
   #+begin_src rust
fn main() {
    let mut x = 42;
    let x_ref = &x;
    x = 13;
    println!("x_ref = {}", x_ref);
    // error: cannot assign to `x` because it is borrowed
}
#+end_src
  :end:

+ While immutably borrowed, a variable cannot be mutably borrowed:
  - üò¶ ~let mut x = 1; let ref1 = &x; let ref2 = &mut x~.
  :full-code:
    #+begin_src rust
fn main() {
    let mut x = 42;
    let x_ref1 = &x;
    let x_ref2 = &mut x;
    // error: cannot borrow `x` as mutable because it is also borrowed as immutable
    println!("x_ref1 = {}", x_ref1);
}
#+end_src
  :end:

--------------------------------------------------------------------------------

*Summary:* Rust provides two variants of most types, those that can be /owned/ and
those that cannot. Unowned types are passed-by-value, or copied.  Loosely put,
this is the difference between /literals/ and /objects/.
#+begin_src rust
fn main() {
    // Literals have no ownership, so the following works fine.
    let x: &str = "hello";
    let y = x;
    dbg!(x, y); // ‚áí "hello", "hello"

    // Objects have a single owner, so the following crashes.
    let x = String::from("hello");
    let y = x; // Now ‚Äòy‚Äô owns the string
    // dbg!(x, y); // Cannot use ‚Äòx‚Äô since it owns nothing!
}
#+end_src

*This is important:* /When we say ~let mut x = thing; let mut y = x~, are updates to
~y~ reflected in ~x~ or not?/ Yes, if ~thing~ is a literal; otherwise it doesn't matter
in Rust since ~x~ can no-longer be used ---multiple mutable references cause
trouble!

/Exercise!/ Confirm that references cannot be owned, by making a similar ~x, y~
setup as above.
:Solution:
    let obj = String::from("hello");

    let x = &obj;
    let y = x;
    dbg!(x, y);
:end:

(For the curious, ~String~ [[https://github.com/rust-lang/rust/blob/master/library/alloc/src/string.rs#L366-L368][is just]] a structure consisting of a vector of integers.)

Incidentally, another difference between literals and objects is their
/lifetimes/. (Objects are heap-allocated.)
#+begin_src rust
fn main() {
    // This works since literals are ‚Äústatic‚Äù; live forever.
    let x = { let y = &"hi"; y };

    // let x = { let y = &"hi".to_string(); y };
    // Error: The string object does not live long enough to be used anywhere else!
    // Note: Consider using a `let` binding to create a longer lived value.

    dbg!(x);
}
#+end_src

/Exercise!/ By making similar ~x, y~ setups as above, confirm that arrays ~[T; n]~ are
unowned and have static lifetimes, whereas vectors ~Vec<T>~ are owned and are
only have dedicated lifetimes.
:Solution:

# // Fails because a vector is heap-allocated, and it has a non-'static lifetime.
#+begin_src rust
fn main() {
    // This works since literals are ‚Äústatic‚Äù; live forever.
    let x = { let a: &[i32; 5] = &[1, 2, 3, 4, 5]; a };

    // let x = { let v: &Vec<i32> = &vec![1, 2, 3, 4, 5]; v };
    // Error: The vector ‚Äòv‚Äô does not live long enough to be used anywhere else!
    // Note: Consider using a `let` binding to create a longer lived value.

    dbg!(x);
}
#+end_src
:End:

* TODO COMMENT Lifetimes
:PROPERTIES:
:CUSTOM_ID: COMMENT-Lifetimes
:END:

** Variables bindings have a "lifetime":
:PROPERTIES:
:CUSTOM_ID: Variables-bindings-have-a-lifetime
:END:
#+begin_src rust
fn main() {
    // `x` doesn't exist yet
    {
        let x = 42; // `x` starts existing
        println!("x = {}", x);
        // `x` stops existing
    }
    // `x` no longer exists
}
#+end_src

** Similarly, references have a lifetime:
:PROPERTIES:
:CUSTOM_ID: Similarly-references-have-a-lifetime
:END:
#+begin_src rust
fn main() {
    // `x` doesn't exist yet
    {
        let x = 42; // `x` starts existing
        let x_ref = &x; // `x_ref` starts existing - it borrows `x`
        println!("x_ref = {}", x_ref);
        // `x_ref` stops existing
        // `x` stops existing
    }
    // `x` no longer exists
}
#+end_src

** The lifetime of a reference cannot exceed the lifetime of the variable binding it borrows:
:PROPERTIES:
:CUSTOM_ID: The-lifetime-of-a-reference-cannot-exceed-the-lifetime-of-the-variable-binding-it-borrows
:END:

#+begin_src rust
fn main() {
    let x_ref = {
        let x = 42;
        &x
    };
    println!("x_ref = {}", x_ref);
    // error: `x` does not live long enough
}
#+end_src

** There is a special lifetime, named 'static, which is valid for the entire program's lifetime.
:PROPERTIES:
:CUSTOM_ID: There-is-a-special-lifetime-named-'static-which-is-valid-for-the-entire-program's-lifetime
:END:
** String literals are ~'static~
:PROPERTIES:
:CUSTOM_ID: String-literals-are-'static
:END:

#+begin_src rust
struct Person {
    name: &'static str,
}

fn main() {
    let p = Person {
        name: "fasterthanlime",
    };
}
#+end_src

** But /owned strings/ are not static
:PROPERTIES:
:CUSTOM_ID: But-owned-strings-are-not-static
:END:

#+begin_src rust
struct Person {
    name: &'static str,
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    let p = Person { name: &name };
    // error: `name` does not live long enough
}
#+end_src

In that last example, the local name is not a &'static str, it's a String. It's
been allocated dynamically, and it will be freed. Its lifetime is less than the
whole program (even though it happens to be in main).

** To store a non-'static string in a struct, it needs to either:
:PROPERTIES:
:CUSTOM_ID: To-store-a-non-'static-string-in-a-struct-it-needs-to-either
:END:

A) Be generic over a lifetime:

#+begin_src rust
struct Person<'a> {
    name: &'a str,
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    let p = Person { name: &name };
    // `p` cannot outlive `name`
}
#+end_src

or

B) Take ownership of the string

#+begin_src rust
struct Person {
    name: String,
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    let p = Person { name: name };
    // `name` was moved into `p`, their lifetimes are no longer tied.
}
#+end_src

** References in function arguments also have lifetimes:
:PROPERTIES:
:CUSTOM_ID: References-in-function-arguments-also-have-lifetimes
:END:


#+begin_src rust
fn print(x: &i32) {
    // `x` is borrowed (from the outside) for the
    // entire time this function is called.
}
#+end_src

Functions with reference arguments can be called with borrows that have different lifetimes, so:

All functions that take references are generic
- Lifetimes are generic parameters
- Lifetimes' names start with a single quote, ':

#+begin_src rust
// elided (non-named) lifetimes:
fn print(x: &i32) {}

// named lifetimes:
fn print<'a>(x: &'a i32) {}
#+end_src

(When there is a single input lifetime, it doesn't need to be named, and
everything has the same lifetime, so the two functions above are equivalent.)

This allows returning references whose lifetime depend on the lifetime of the arguments:

#+begin_src rust
struct Number {
    value: i32,
}

fn number_value<'a>(num: &'a Number) -> &'a i32 {
    &num.value
}

fn main() {
    let n = Number { value: 47 };
    let v = number_value(&n);
    // `v` borrows `n` (immutably), thus: `v` cannot outlive `n`.
    // While `v` exists, `n` cannot be mutably borrowed, mutated, moved, etc.
}
#+end_src

** Structs can also be generic over lifetimes, which allows them to hold references:
:PROPERTIES:
:CUSTOM_ID: Structs-can-also-be-generic-over-lifetimes-which-allows-them-to-hold-references
:END:

#+begin_src rust
struct NumRef<'a> {
    x: &'a i32,
}

fn main() {
    let x: i32 = 99;
    let x_ref = NumRef { x: &x };
    // `x_ref` cannot outlive `x`, etc.
}
#+end_src

The same code, but with an additional function:

#+begin_src rust
struct NumRef<'a> {
    x: &'a i32,
}

fn as_num_ref<'a>(x: &'a i32) -> NumRef<'a> {
    NumRef { x: &x }
}

fn main() {
    let x: i32 = 99;
    let x_ref = as_num_ref(&x);
    // `x_ref` cannot outlive `x`, etc.
}
#+end_src

The same code, but with "elided" lifetimes:

#+begin_src rust
struct NumRef<'a> {
    x: &'a i32,
}

fn as_num_ref(x: &i32) -> NumRef<'_> {
    NumRef { x: &x }
}

fn main() {
    let x: i32 = 99;
    let x_ref = as_num_ref(&x);
    // `x_ref` cannot outlive `x`, etc.
}
#+end_src

** impl blocks can be generic over lifetimes too:
:PROPERTIES:
:CUSTOM_ID: impl-blocks-can-be-generic-over-lifetimes-too
:END:

#+begin_src rust
impl<'a> NumRef<'a> {
    fn as_i32_ref(&'a self) -> &'a i32 {
        self.x
    }
}

fn main() {
    let x: i32 = 99;
    let x_num_ref = NumRef { x: &x };
    let x_i32_ref = x_num_ref.as_i32_ref();
    // neither ref can outlive `x`
}
#+end_src

But you can do elision ("to elide") there too:
#+begin_src rust
impl<'a> NumRef<'a> {
    fn as_i32_ref(&self) -> &i32 {
        self.x
    }
}
#+end_src

You can elide even harder, if you never need the name:
#+begin_src rust
impl NumRef<'_> {
    fn as_i32_ref(&self) -> &i32 {
        self.x
    }
}
#+end_src

* Types
:PROPERTIES:
:CUSTOM_ID: types
:END:

 Rust is a statically & strongly typed language: It knows the types of all
 variables at compile time ---it can infer them if you don't write them--- and
 it does no implicit type coercions.

#+macro: go src_rust[:exports code]{$1}
|----------------------------+---------------------------------------------------------------------------------------------------------------|
| Type                       | Explanation                           ; Example value                                                         |
|----------------------------+---------------------------------------------------------------------------------------------------------------|
| Integers ~i32, u32~          | Number without decimals               ; ~123~                                                                   |
| Floats ~f32, f64~            | Numbers with decimals                 ; =-1.23, 1e4=                                                            |
| Booleans ~bool~              | Truth values                          ; ~true, false, !p, p && q, p ‚à• q~                                        |
| Characters ~char~            | Unicode characters                    ; ~'t', 'üòª'~                                                             |
|----------------------------+---------------------------------------------------------------------------------------------------------------|
| Tuples ~(œÑ‚ÇÄ, œÑ‚ÇÅ, ‚Ä¶, œÑ‚Çô‚Çã‚ÇÅ)~   | $n$ things of different types         ; ~(1, 'a', 2.3)~                                                         |
| Unit ~()~                    | A ‚Äúzero-tuple‚Äù; denotes ‚Äúdone‚Äù; value is written ~()~                                                           |
| Arrays ~[œÑ; n]~              | $n$ things of the same type           ; ~[1, 2, 3]~                                                             |
| Vectors ~Vec<œÑ>~             | Like arrays, but can increase in size ; ~vec![1, 2, 3]~                                                         |
| Slices ~[œÑ]~               | Slices are similar to arrays, but their length is not known at compile time.                                  |
| Structures                 | A record, hashmap, lightweight class; key-value pairs                                                         |
| Enums                      | Constants; algebraic data-types                                                                               |
| Ranges                     | $m..n$ is the sequence of integers $i$ with $m ‚â§ i < n$.                ; ~3..7~                                |
|----------------------------+---------------------------------------------------------------------------------------------------------------|
| Functions ~(œÑ‚ÇÅ, ‚Ä¶, œÑ‚Çô) ‚Üí œÑ~  | Transform œÑ·µ¢ into a œÑ                 ; @@latex:{\scriptsize@@ ~fn first<A, B>(a:A, b:B) -> A { a }~ @@latex:}@@ |
|----------------------------+---------------------------------------------------------------------------------------------------------------|
| [Read-only] References ~&œÑ~  | Refer to an object, without owning it ; ~let s = ‚ãØ; &s~ ;; ~let x = &4~                                           |
| Mutable references ~&mut œÑ~  | Borrow an object and change it        ; ~let mut s = ‚ãØ; &mut s~ ;; ~let x = &mut 4~                               |
|----------------------------+---------------------------------------------------------------------------------------------------------------|
| String Slices, ~&str~        | A string literal that can only be borrowed, but not owned/mutated; =let five = "5"=                             |
| [Growable] Strings, ~String~ | Strings that can grow in size; essentially ~Vec<&str>~;; ~let five = "5".to_string()~                             |
|----------------------------+---------------------------------------------------------------------------------------------------------------|

+ *Slices* are the answer to ‚ÄúWhat is the input type of a function that consumes
  arrays /but/ doesn't know their length?‚Äù Slices act like temporary views into an
  array or a vector.

+ Rust vectors are [[https://hashrust.com/blog/arrays-vectors-and-slices-in-rust/#:~:text=How%20does%20a,the%20old%20array.][array-lists]]: They're arrays that double in size whenever
  more space is needed.

+ Range Example: ~(1..5).for_each(|i| println!("{}", i));~

# A /scalar/ type represents a single value; e.g., numbers, booleans, and
# characters. Whereas /compound types/ can group multiple values into one type;
# e.g., tuples and arrays.

+ The unit type, ~()~, is often used as the /return type/ of functions that have
  side-effects, such as printing to the screen. Everything has to have a type, so
  ~()~ (which can be read ‚Äúdone‚Äù) can be that type. The default return type of
  functions is ~()~, unless explicitly indicated otherwise.

+ For ùìÉ in {8, 16, 32, 64}, a number of bits, there are /signed integers/ ~iùìÉ~ which
  can store numbers from $-2^{n}$ to $2^{n - 1} - 1$ inclusive, and /unsigned
  integers/ ~uùìÉ~ which store numbers from $0$ to $2^{n}$.

  # An integer is a number without a fractional component; e.g., ~u32~ and ~i32~.

  - These types provide bounds on numbers; e.g., src_rust[:exports code]{let it:
    u8 = 256} results in a compile error since 256 is out of range for
    src_rust[:exports code]{u8}.
  - By default, numeric variables without an explicit type are assigned type
    src_rust[:exports code]{i32}, if possible.
  - Numbers have the expected arithmetic operations src_emacs-lisp[:exports code]{+, -, /, %} (remainder).
  - Underscores can be inserted in numeric literals to improve readability,
    e.g. =1_000= is the same as =1000=, and =0.000_001= is the same as =0.000001=.

  :More:
      #+begin_src rust
  let a_float: f64 = 1.0;  // Regular annotation
   let an_integer   = 5i32; // Suffix annotation

  // Use underscores to improve readability!
  println!("One million is written as {}", 1_000_000u32);
  #+end_src

  #  Functions can use tuples to return multiple values, as tuples can hold any number of values.

     We need to tell the compiler the type of the literals we use. For now, we'll use
     the u32 suffix to indicate that the literal is an unsigned 32-bit integer, and
     the i32 suffix to indicate that it's a signed 32-bit integer.

    # There is also ~isize~ which are numeric types that specialise to ~i32~ /or/ ~i64~,
    # depending on whether we're compiling on a 32-bit machine or a 64-bit
    # machine. Likewise for ~usize~.
  :End:

* TODO COMMENT Block, Expressions, and Functions
:PROPERTIES:
:CUSTOM_ID: block-expressions-and-functions
:END:

Blocks are chunks of code surrounded by curly braces. They introduce a /new scope/
(shadowing any variables in the parent scope) and are /expressions/ and so have a
value ---being the value of the final expression within the block.
(This means ~‚Ñ∞ == {‚Ñ∞}~ for any expression ‚Ñ∞.)
# That's why "omitting the semicolon at the end of a function" is the same as returning.
:mwe_Scopes:
#+begin_src rust
    let x = "outside";
    {
        let x = "inside";
        assert!(x == "inside");
    }
    assert!(x == "outside");

#+end_src
:End:

#+begin_parallel

#+begin_src rust
fn main() {
    let z = {
        let (x, y) = (1, 2);
        x + y
    };
    assert!(z == 3);
}
#+end_src

#+RESULTS:

#+columnbreak:

If the block's expression ends in a semicolon src_emacs-lisp[:exports code]{;}, then it becomes a
statement and so the final line would become: src_rust[:exports code]{assert!(z == ());}!

#+end_parallel

/Statements/ are instructions that perform some action and do not return a value
---which is expressed by ~()~, the unit type. /Expressions/ evaluate to a resulting
value; e.g., blocks ~{}~ are used to create new scopes but are expressions, as are
function (and macro) calls.

# Statements do not return values; e.g., ~let x = 5~ does not return anything.
#    let x = println!("hi"); // In such cases, we use ‚Äúlet _ = ‚ãØ‚Äù.
#    assert!(x == ());

A /function/ is a block that is /named, parameterised, and typed/.  It is declared
with the src_rust[:exports code]{fn} keyword; its arguments /must/ be typed and
the resulting type of the function is declared with ~->~ (omitted when void).
The types are required so that Rust can infer them at use sites.

# Requiring type annotations in function definitions means the compiler almost
# never needs you to use them elsewhere in the code to figure out what you mean.

#+begin_src rust
// (Generic) functions can have multiple type parameters
fn first<A, B>(a: A, b: B) -> A {
    a
}
// To require ‚ÄòA‚Äô implements interfaces ‚ÄòI‚ÇÅ‚Äô and ‚ÄòI‚ÇÇ‚Äô,
// we write ‚Äòfn first<A: I‚ÇÅ + I‚ÇÇ, B>‚Äô.
// E.g., `fn first<A: Debug + PartialEq, B> { ‚ãØ }`.

fn main() {
    assert!('a' == first('a', 1));
    assert!('a' == first::<char, i32>('a', 1)); // Explicit type application
}
#+end_src

# ‚Äútype parameters‚Äù can then be used in the function's declaration and its body, instead of concrete types.

+ Rust doesn‚Äôt care where you define your functions, only that they‚Äôre defined
  somewhere.
  #+latex: \hfill
  We could have defined src_rust[:exports code]{first}
  /after/ src_emacs-lisp[:exports code]{main} or
  /within/ src_emacs-lisp[:exports code]{main}.

+ A function's return value, like a block, is the final expression.  But one can
  use src_rust[:exports code]{return expr;} to exit ‚Äúin the middle‚Äù of a function.

+ There's a longer syntax for type parameter constraints:
  ~fn print<T>(value: T) where T : Display { println!("{}", value) }~.

  TODO:hello
  #+begin_src rust
fn foobar<F>(x: i32, y: i32, is_greater: F)
    where F: Fn(i32, i32) -> bool
{
    let (greater, smaller) = if is_greater(x, y) {
        (x, y)
    } else {
        (y, x)
    };
    println!("{} is greater than {}", greater, smaller);
}

fn main() {
    foobar(32, 64, |x, y| x > y);
}
  #+end_src

+ Just as namespaces are ‚Äònavigated‚Äô with ~::~, so too
  generic functions are /specialised/ with ~::<>~ ---this is [[https://matematikaadit.github.io/posts/rust-turbofish.html][turbofish syntax]].
  E.g., ~first::<i32, bool>(12, false)~ is an example usage.
  # Generic functions can be thought of as namespaces, containing an infinity of functions with different concrete types.
  # Same as with crates, and modules, and types, generic functions can be "explored" (navigated?) using ::

* Tuples and Arrays
:PROPERTIES:
:CUSTOM_ID: COMMENT-Tuples-and-Arrays
:END:

# TUPLES
# A tuple is a general way of grouping together a number of values with a variety
# of types into one compound type. Tuples have a fixed length: once declared, they
# cannot grow or shrink in size.

# ARRAYS
# Another way to have a collection of multiple values is with an array. Unlike a
# tuple, every element of an array must have the same type. Arrays in Rust are
# different from arrays in some other languages because arrays in Rust have a
# fixed length, like tuples.

Both tuples and arrays collect multiple values and have fixed (non-growable)
sizes; the only difference is that the values in a tuple can be of a different
type whereas an array requires them to all have the same type.

#+begin_src rust :prologue
fn main() {
    // Create: Tuples, different types allowed
    let p = ('a', 1, 2.3, "bye");
    let q: (char, i32) = ('a', 12); // Explicit type annotation

    // Create: Arrays, can only be same type
    let a = [1, 2, 3];
    let b : [char; 2] = ['x', 'y']; // Explicit type annotation

    // Read: Tuples, with ‚Äú .ùíæ ‚Äù notation
    // Read: Arrays, with ‚Äú [ùíæ] ‚Äù notation
    println!("{0}, {1}, {2}", q.0, p.3, a[1]); // p.4, a[4] ‚áí Error!

    // Both can be *destructured*, but must match in length
    let (_, me, _, you) = p; // ‚âà  let me = p.1; let you = p.3;
    let [_, them, _]    = a; // ‚âà  let them = a[1];

    // Example: A super simple way to swap
    let x = 1; let y = 2;
    assert!(x == 1 && y == 2);
    let (y, x) = (x, y);       // Shadowing
    assert!(x == 2 && y == 1);

    // Shorthand for constant arrays
    assert!([2, 2, 2, 2] == [2; 4]);
}
#+end_src

#+RESULTS:
: error: Could not compile `cargoUS5aVu`.

~[œÑ; n]~ is the type of arrays of length $n$ with elements from type œÑ.
#+latex: \newline
If œÑ is a value, then there is only one possible array: ~[œÑ, œÑ, ..., œÑ]~ (/n/-many
times).

# Arrays are useful when you have a list whose length you do not expect to change
# ---e.g., a list of the months.
#
# A vector is a similar collection type provided by the standard library that is
# allowed to grow or shrink in size. If you‚Äôre unsure whether to use an array or a
# vector, you should probably use a vector. Chapter 8 discusses vectors in more
# detail.

# Invalid array index ‚áí Immediate program exit; a run-time error.
#
# The program resulted in a runtime error at the point of using an invalid value
# in the indexing operation. The program exited at that point with an error
# message and didn't execute the final println!. When you attempt to access an
# element using indexing, Rust will check that the index you‚Äôve specified is less
# than the array length. If the index is greater than or equal to the array
# length, Rust will panic. This check has to happen at runtime, especially in this
# case, because the compiler can't possibly know what the value a user running the
# code will later enter.


We can loop over an array as follows.
#+begin_src rust
fn main() {
    let names = ["me", "you", "them"];
    for name in names {
        println!("{}", name)
    }
}
#+end_src

#+RESULTS:
: me
: you
: theme

/Exercise!/ Use a vector, src_rust[:exports code]{let names = vec!["me", "you",
"them"]}, and try to (/debug/-)print src_rust[:exports code]{names} after the
loop. Notice that src_rust[:exports code]{name} lost /ownership/ of its value to
the src_rust[:exports code]{for‚ãØin} loop. Fix this by giving the loop a
reference, src_rust[:exports code]{&names}.
:Solution:
#+begin_src rust
fn main() {
    let names = vec!["me", "you", "theme"];
    for name in &names {
        println!("{}", name)
    }
    println!("{:?}", names)
}
#+end_src
:End:

* Slices ---and ~str~
:PROPERTIES:
:CUSTOM_ID: Slices-and-str
:END:

If we have an array/vector/string/collection, how do we reference a slice of
their memory; i.e., narrow our view to a sub-part of the entire whole? The
answer is ‚Äúslice types‚Äù.

Slices are similar to arrays, but their length is not known at compile
time. Essentially, slices are ‚Äúviews into segments of data‚Äù and [[https://stackoverflow.com/a/27150865/17693195][so consists of
two-parts]]: a pointer to the start of the data, and the length of the
data. Below, with a bit of [[https://stackoverflow.com/a/24761180/17693195][pointer arithmetic]], we can use slices as these
two-parts ---but this is not recommended!

- [[https://doc.rust-lang.org/reference/types/slice.html][A slice]], ~[œÑ]~, is a view into a block of memory. Whether mutable or not, /a
  slice always borrows/ and that is why it is always behind a [[https://doc.rust-lang.org/reference/types/pointer.html][pointer]], &.  Thus,
  sometimes people say ‚Äúslices are &[œÑ]‚Äù.
- Since references are unowned, so too slices ~&[œÑ]~ are unowned.

#+begin_src rust
fn main() {
    let array: [i32; 5] = [11, 22, 33, 44, 55];
    let slice: &[i32] = &array;

    // Decompose a slice into its two main parts
    let length = slice.len(); // ‚áí 3
    let pointer = slice.as_ptr(); // ‚áí Some memory address

    // The ùìÉth element is ùìÉ-steps away from the starting pointer.
    // (This is why elements start at index 0.)
    dbg!(unsafe { *pointer.offset(1) }); // ‚áí 22

    // If you do a pointer offset out of bounds, like 4, you've just accessed more memory;
    // possibly by accident and not the memory you want!

    // Safe way to do indexing; which checks for bounds at run-time.
    let element = slice[2]; // ‚áí 33
                            // let element = slice[4]; // Index out of bounds error!

    // An even safer way, that does not crash at run-time.
    let element = slice.get(4); // ‚áí None

    // Get a sub-slice start at index 2 up to, and including, index 3.
    let sub: &[i32] = &slice[2..=3]; // ‚áí [33, 44]

    // You can (mutably) borrow a slice of a (mutable) vector, or string, etc.
    let mut v = vec![1, 2, 3, 4, 5];
    let s = &mut v[2..]; // ‚áí [3, 4, 5]
    s[0] = 333;
    assert!(s == [333, 4, 5]);
    assert!(v == vec![1, 2, 333, 4, 5]);
}
#+end_src

#+RESULTS:
: [src/main.rs:7] std::mem::size_of_val(&slice) = 16
: [src/main.rs:8] std::mem::size_of_val(&array) = 20
: [src/main.rs:16] unsafe { *pointer.offset(1) } = 22

# Rust has slices - they're a reference to multiple contiguous elements.

We borrow slices of ~x : œÑ~ using ~&x[..]~ /provided/ the type œÑ implements the ~Index~
and ~IndexMut~ traits, which let us using the indexing operator.  The ‚Äú..‚Äù  syntax
is for range literals: ~.., 0.., ..20, ..=20, 3..6~ are all example ranges with
~m..n~ denoting all integers $i$ with $m ‚â§ i < n$ ---and the right-bound can be
made inclusive using ‚Äò=‚Äô. More concretely, ~(..=20).contains(&13)~ is true since
the range ~..=20~ is all integers at-most 20.
- References are implicitly converted into slices, when possible, by treating ~&x~
  as if it were ~&x[..]~.

[Mutable Slices] /Notice that changing the value of a slice index also changes
the value in the/ /underlying array/vector/string ---which actually owns the
values that the slice is letting us look at./

Since slices can be formed from vectors and arrays, if we want a function to
work on both kinds of values, we make our function consume a slice: Values of
~&Vec<T>~ and ~&[T; n]~ are implicitly transformed into values of ~&[T]~.
- Likewise, for ~&str~ and ~String~, the more generic approach is functions
  consuming ~&str~.

Rust's strings are all Unicode and so characters differ in size, as such string
slices cannot be implemented with a pointer and accessed with a uniform offset,
like ~[T]~. As such, there is a special type ~str~, ‚Äústring slices‚Äù, which fullfills
this role. ~str~ really acts like slice types; e.g., ~"hello"~ has type ~str~ and
~&"hello"[1..]~ has type ~&str~; yet ~assert!(&"hello"[1..] == "ello")~ is true.


:Examples:
#+begin_src rust
fn main() {
    dbg!((..=20).contains(&-13));

    // 0 or greater
    println!("{:?}", (0..).contains(&100)); // true
                                            // strictly less than 20
    println!("{:?}", (..20).contains(&20)); // false
                                            // 20 or less than 20
    println!("{:?}", (..=20).contains(&20)); // true
                                             // only 3, 4, 5
    println!("{:?}", (3..6).contains(&4)); // true
}
#+end_src
:End:

* COMMENT BORROWING = PASSING BY REFERENCE; otherwise ownership
:PROPERTIES:
:CUSTOM_ID: COMMENT-BORROWING-PASSING-BY-REFERENCE-otherwise-ownership
:END:
* TODO [#A] COMMENT Reads --------------------------------------------------------------------------------
:PROPERTIES:
:CUSTOM_ID: COMMENT-Reads
:END:

TODO:HERE
https://doc.rust-lang.org/rust-by-example/custom_types/structs.html

http://saidvandeklundert.net/learn/tags/#rust

+ [X] [[https://doc.rust-lang.org/rust-by-example/hello.html][Rust By Example]]; online runnable snippets
+ [ ] [[https://stevedonovan.github.io/rust-gentle-intro/print.html][A Gentle Introduction to Rust]]
+ [ ] [[https://hashrust.com/blog/][HashRust Blog]]
+ [X] [[https://fasterthanli.me/articles/a-half-hour-to-learn-rust][A half-hour to learn Rust]]

  In order to increase fluency in a programming language, one has to read a lot
  of it. But how can you read a lot of it if you don't know what it means?

  In this article, instead of focusing on one or two concepts, I'll try to go
  through as many Rust snippets as I can, and explain what the keywords and
  symbols they contain mean.
+ [ ] [[https://this-week-in-rust.org/][This Week in Rust]]: Handpicked Rust updates, delivered to your inbox.
  - Stay up to date with events, learning resources, and recent developments in Rust community.



--------------------------------------------------------------------------------

Looks super neato! https://tourofrust.com/00_en.html

Seems good: https://github.com/Dhghomon/easy_rust/blob/master/README.md#mutability-changing

https://exercism.io/tracks/rust

https://github.com/rust-lang/rustlings

https://gitconnected.com/learn/rust

https://towardsdatascience.com/you-want-to-learn-rust-but-you-dont-know-where-to-start-fc826402d5ba

https://hackr.io/tutorials/learn-rust

[[https://www.chiark.greenend.org.uk/~ianmdlvl/rust-polyglot/intro.html][Introduction and overview - Rust for the Polyglot Programmer]]

Follow Olivia Ifrim's Sokobon Tutorial 22 where you implement a simple windowed
2D sokobon game in Rust. This tutorial also doesn't assume you know any Rust so
it's also very approachable for absolute beginners.  https://sokoban.iolivia.me/

Follow Philipp Flenker's Hecto Tutorial 22 where you implement a simple vim-like
terminal text editor in Rust. The tutorial doesn't assume you know any Rust so
it's very approachable even for absolute beginners.
https://www.philippflenker.com/hecto/

One great general beginner resource I couldn't fit above but still recommend to
read and reference is David MacLeod's Easy Rust 25.
https://github.com/Dhghomon/easy_rust/blob/master/README.md

+ [ ] [[https://www.rust-lang.org/learn][Learn Rust - Rust Programming Language]]

+ [ ] [[https://rust-unofficial.github.io/too-many-lists/][Introduction - Learning Rust With Entirely Too Many Linked Lists]]

+ [ ] [[https://fasterthanli.me/articles/a-half-hour-to-learn-rust][A half-hour to learn Rust - fasterthanli.me]] [Would not suggest this as an
  intro tutorial to anyone!]
  ‚åò+f is also a macro. It violently stops execution


Some great resources for advanced beginners on specific aspects of Rust where people commonly struggle with are:
+ Clear Explanation of Rust's Module System 16 by Sheshbabu Chinnakonda
  http://www.sheshbabu.com/posts/rust-module-system/
+ Common Rust Lifetime Misconceptions 2
  https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md
+ Sizedness in Rust 9
  https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md

** COMMENT super neat stuff
:PROPERTIES:
:CUSTOM_ID: COMMENT-super-neat-stuff
:END:

/consider/ adding snippets to
https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=98f4284c0826e7977fc8b2d75b9c3cc6
;-)

** COMMENT What if I want ~N~ columns? Or non-landscape? Or multiple formats?
  :PROPERTIES:
  :CUSTOM_ID: COMMENT-What-if-I-want-N-columns-Or-non-landscape-Or-multiple-formats
  :END:

Press ~C-c C-c~ on the following incantation to produce a single column portrait of the cheat sheet.
#+name: make-portrait
#+BEGIN_SRC emacs-lisp :results none
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: CheatSheet_Portrait.pdf
     ,#+LATEX_HEADER_EXTRA: \\landscapefalse \\def\\cheatsheetcols{1}
     ,#+INCLUDE: CheatSheet.org
    ")

    (let ((org-export-use-babel nil))
      (org-mode)
      (org-latex-export-to-pdf)
      )
)
#+END_SRC
** COMMENT Making ~README.org~
  :PROPERTIES:
  :CUSTOM_ID: COMMENT-Making-README-org
  :END:

  Evaluate the following source block with ~C-c C-c~
  to produce a ~README~ file.

  # :'( For some reason using {{{title}}} below would not work.

#+NAME: make-readme
#+BEGIN_SRC emacs-lisp
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.md
     ,#+HTML: <h1> AngularJSCheatSheet </h1>
     ,#+OPTIONS: toc:nil d:nil
     # Toc is displayed below at a strategic position.

     {{{blurb}}}

    ,*The listing sheet, as PDF, can be found
     [[file:CheatSheet.pdf][here]]*;
     while below is an unruly html rendition
     ---there is also a
     badge:beautiful|HTML_webpage|success|https://alhassy.github.io/RustCheatSheet|javascript (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

     # Markdown links: [title](target)

     This reference sheet is built from a
     [[https://github.com/alhassy/CheatSheet][CheatSheets with Org-mode]]
     system.

     ,#+TOC: headlines 2
     ,#+INCLUDE: CheatSheet.org
    ")

    ;; No code execution on export
    ;; ‚ü™ For a particular block, we use ‚Äú:eval never-export‚Äù ‚ü´
    ;;
    (let ((org-export-use-babel nil))
      (org-mode)
      (org-md-export-to-markdown)
      )
)
#+END_SRC

#+RESULTS: make-readme
: README.md

Note that the ~blurb~ macro is defined by the user, to provide a terse description of the project.
   - Think the one-line statement at the top of a github repo page.

#    The ~d:nil~ ensures the ‚Äòdrawer‚Äô ~:Hide: ‚ãØ :End:~ is not exported; it's there for me
#    as a reminder.
** COMMENT You can even compile Rust into WebAssembly in order to run it in-browser!
:PROPERTIES:
:CUSTOM_ID: COMMENT-You-can-even-compile-Rust-into-WebAssembly-in-order-to-run-it-in-browser
:END:
* TODO COMMENT [[https://doc.rust-lang.org/book/ch05-02-example-structs.html][Structures]] ---‚ÄúTuples with /named and unordered/ components‚Äù
:PROPERTIES:
:CUSTOM_ID: COMMENT-https-doc-rust-lang-org-book-ch05-02-example-structs-html-Structures-Tuples-with-named-and-unordered-components
:END:

Structures /provide ways to group several values into a single value./
/Conceptually, this allows us to put a bunch of related things in a bag and run
around with the bag, instead of wrapping our arms around all of the individual/
/things and trying to hold on to them separately./ ---[[https://eloquentjavascript.net/04_data.html#p_78ZfHX5x1B][Eloquent JavaScript]]

A src_rust[:exports code]{struct}ure is also known as a /record, hashmap, association list,
lightweight-class, JSON object/.  Struct types are /formed/ as name-type pairs, and
their values are /constructed/ with ‚Äòstruct literals‚Äô: Name-value pairs preceded
by the struct name.

TODO: Maybe move tuples to be here? Since they're just anonomous structs?
https://doc.rust-lang.org/reference/types/struct.html

[Note that tuples, arrays, enums, and ranges can all be /thought of/ as
specialisations of the idea of structures. That is, structures are powerful
enough to implement the previously mentioned compound types.]

+ Tuples /quickly/ group related variables together, but structs give us /meaning/
  by /naming/ the variables ---instead of using numeric indices.

 #+begin_src rust :prologue "fn main() {" :epilogue "}"
// ‚ü®0‚ü© Forming a new type
#[derive(Debug)]   // Simple debug printing
struct Person {
    name : String,
    job  : String,
    age  : u32
}

// ‚ü®1‚ü© Introducing a value of that type
let mut job = String::from("farmer");
let mut jay = Person {
    name: String::from("jason"),
    age: 72,
    job // Shorthand for same name, but *cloned* value:   job: String::form("farmer")
};
// Mutability of ‚Äújob‚Äù and ‚Äújay‚Äù are not related at all.
job = String::from("labourer");       // Has no effect on ‚Äújay‚Äù
assert!(jay.job == "farmer");

// ‚ü®2‚ü© Eliminating a value of that type by destructuring
// [Ownership moves: If ‚Äújay.field‚Äù is an object, it has moved to ‚Äúfield‚Äù]
// [Namely, after this line, /read access/ of ‚Äújay.name‚Äù is invalid.]
let Person {name, age, ..} = jay; // The ‚Äú..‚Äù are to ignore the rest

// ‚ü®3‚ü© Updating a field [Give ‚Äújay.name‚Äù a value and so it is valid to read.]
jay.name = String::from("jasim");
assert!(jay.name == "jasim" && name == "jason");

// Using the automatic debug printing
println!("Jay is {:?}", jay); // Pretty print with: {:#?}

// ‚ü®4‚ü© Let's attach a method to our struct instances
impl Person {
    fn speak(&self) {
        println!("{}: I am a {} years old.", self.name, self.age);
    }
}
// Let's use this method.
jay.speak();

// ‚ü®1‚ü©' Creating instances from instances; ‚Äúprototyping‚Äù!
// [Read: kathy is like jay but has a different name.]
// [This ‚Äústruct update syntax‚Äù can only happen in the last position.]
// [In-particular, ‚ÄúPerson {..jay}‚Äù is a clone of the value ‚Äújay‚Äù.]
let kathy = Person {name: String::from("Kalthum"), ..jay};
// ‚ü®4‚ü©‚Ä≤ We can call methods using type-namespace syntax.
Person::speak(&kathy);

// ‚ü®1‚ü©‚Ä≥ We can also make unnamed fields, and use tuple indexing
struct Mine(String, u32);
let mut it = Mine(String::from("hola"), 23);
it.1 = 12;
 #+end_src

 #+RESULTS:
 : Jay is Person { name: "jasim", job: "farmer", age: 72 }
 : jasim: I am a 72 years old.
 : Kalthum: I am a 72 years old.

src_rust[:exports code]{// ‚ü®4‚ü©}
The function ~fn greet(p: &Person) { println!("{}: I am a {}.", p.name, p.job) }~
is very specific: It only works on ~Person~ values. As such, it's helpful to tie
this behaviour more closely to the ~Person~ struct, which can be done by moving it
into an ‚Äúimpl‚Äùementation block. All methods in an ~impl~ block must have the first
argument named ~self~. As such, we could have written ~fn speak(self: &Person) {‚ãØ}~.
However, within an ~impl~ block, the type ~Self~ is an alias for the type that the
~impl~ block is for. As such, we could have written ~fn speak(self: &Self) {‚ãØ}~.
Since the first argument of methods must be /named/ ~self~ and /typed/ ~Self~, we can
just abbreviate it to ~self: Self~ to ~self~ ---however, in our case we use the
abbreviation ~&self~ because we want the value to be /borrowed/, not owned.

/Exercise!/ Change ~speak~ above to consume a mutable reference, ~&mut self~, that
increments the age. Two other non-mutable things will now break in the above
program; make them mutable. Make ~kathy~ speak twice and ~assert!~ her age has
changed.
:Solution:
#+begin_src rust
impl Person {
    fn speak(&mut self) {
        println!("{}: I am a {} years old.", self.name, self.age);
        self.age = self.age + 1
    }
}

let mut kathy = Person {name: String::from("Kalthum"), ..jay};

Person::speak(&mut kathy);
Person::speak(&mut kathy);
#+end_src

:End:

/Exercise!/ Struct methods can have the same name as struct fields ---whereas
arbitrary functions cannot share the name of variables. Change the method name src_rust[:exports code]{speak} to be src_rust[:exports
code]{age}.

# Everything within this impl block will be associated with the type.


# /Methods/ are different from functions in that they‚Äôre defined within the context
# of a struct (or an enum or a trait object), and their first parameter is always
# ~self~, which represents the instance of the struct the method is being called on.
# The /method syntax/ goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.


-----

It‚Äôs possible for structs to store /references/ ---such as src_rust[:exports
code]{&str} values--- to data owned by something else, but to do so requires the
use of ‚Äúlifetimes‚Äù, a Rust feature that ensures that the data referenced by a
struct is valid for as long as the struct is. The use of references in a
structure definition means that the structure does not own all of its data, but
that some of its data is borrowed.

--------------------------------------------------------------------------------

#+begin_src rust
// The `derive` attribute automatically creates the implementation
// required to make this `struct` printable with `fmt::Debug`.
#[derive(Debug)]
struct DebugPrintable(i32);
#+end_src


// To use the `{}` marker, the trait `fmt::Display` must be implemented
// manually for the type.
- https://doc.rust-lang.org/rust-by-example/hello/print/print_display.html
- https://doc.rust-lang.org/rust-by-example/hello/print/print_debug.html
- https://doc.rust-lang.org/rust-by-example/hello/print/fmt.html

** Structs can be generic too:
:PROPERTIES:
:CUSTOM_ID: Structs-can-be-generic-too
:END:

#+begin_src rust
struct Pair<T> {
    a: T,
    b: T,
}

fn print_type_name<T>(_val: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let p1 = Pair { a: 3, b: 9 };
    let p2 = Pair { a: true, b: false };
    print_type_name(&p1); // prints "Pair<i32>"
    print_type_name(&p2); // prints "Pair<bool>"
}
#+end_src

#+RESULTS:
: cargoXvOHKv::Pair<i32>
: cargoXvOHKv::Pair<bool>


** COMMENT Structs
:PROPERTIES:
:CUSTOM_ID: COMMENT-Structs
:END:

#+begin_src rust :tangle no
fn main() {
    // Structs are declared with the struct keyword:
    struct Number {
        odd: bool,
        value: i32,
    }

    // They can be initialized using struct literals:
    let n = Number {
        odd: true,
        value: 11,
    };

    // Structs, like tuples, can be destructured.
    let Number { odd, .. } = n;

    // Projection
    assert!(odd && n.value == 11);

    // Mutable updates
    let mut _m = Number { ..n }; // Copy n's data
    _m.value = 32;

    // let patterns can be used as conditions in ‚Äúif‚Äù
    if let Number { odd: true, .. } = n {
        "yay"
    } else {
        "nay"
    };

    // match arms are also patterns, just like if let:
    // match n { Number {odd, ..} => "has an ODD field", _ => "nope"};
}
#+end_src

#+RESULTS:

# + ~if p.x‚ÇÅ == y‚ÇÅ && p.x‚ÇÇ == y‚ÇÇ && p.x‚ÇÉ == y‚ÇÉ ‚ãØ  ‚âà  if let P {x‚ÇÅ: y‚ÇÅ, x‚ÇÇ: y‚ÇÇ, x‚ÇÉ: y‚ÇÉ, ..} = p ‚ãØ~

You can declare methods on your own types:
#+begin_src rust
struct Number { odd: bool,
        value: i32,
    }

impl Number {
    fn is_strictly_positive(self) -> bool {
        self.value > 0
    }
}

fn main() {
    let n = Number {
        odd: true,
        value: 11,
    };
    assert!(n.is_strictly_positive());
    println!("HOLA");
}
#+end_src

Structs can be generic too:
#+begin_src rust
struct Pair<A, B> {
    first: A,
    second: B,
}

fn main() {
    assert!(
        (Pair {
            first: 1,
            second: 'b'
        })
        .first
            == 1
    );
}
#+end_src

*** COMMENT {:?}
:PROPERTIES:
:CUSTOM_ID: COMMENT
:END:

  The println! macro call will now look like println!("rect1 is {:?}",
  rect1);. Putting the specifier :? inside the curly brackets tells println! we
  want to use an output format called Debug. The Debug trait enables us to print
  our struct in a way that is useful for developers so we can see its value
  while we‚Äôre debugging our code.

we‚Äôll see the following output:


$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 is Rectangle { width: 30, height: 50 }
Nice! It‚Äôs not the prettiest output, but it shows the values of all the fields for this instance, which would definitely help during debugging. When we have larger structs, it‚Äôs useful to have output that‚Äôs a bit easier to read; in those cases, we can use {:#?} instead of {:?} in the println! string. When we use the {:#?} style in the example, the output will look like this:


$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 is Rectangle {
    width: 30,
    height: 50,
}


- Rust also provides "pretty printing" with {:#?}.
* TODO COMMENT Enums ~ Option
:PROPERTIES:
:CUSTOM_ID: COMMENT-Enums-Option
:END:
The Option type can contain something, or it can contain nothing. If .unwrap() is called on it, and it contains nothing, it panics:

#+begin_src rust
fn main() {
    let o1: Option<i32> = Some(128);
    o1.unwrap(); // this is fine

    let o2: Option<i32> = None;
    o2.unwrap(); // this panics!
}

// output: thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:378:21
#+end_src

# Haskell's Maybe Type.




** Option is not a struct - it's an enum, with two variants.
:PROPERTIES:
:CUSTOM_ID: Option-is-not-a-struct-it's-an-enum-with-two-variants
:END:

#+begin_src rust
enum Option<T> {
    None,
    Some(T),
}

impl<T> Option<T> {
    fn unwrap(self) -> T {
        // enums variants can be used in patterns:
        match self {
            Self::Some(t) => t,
            Self::None => panic!(".unwrap() called on a None option"),
        }
    }
}

use self::Option::{None, Some};

fn main() {
    let o1: Option<i32> = Some(128);
    o1.unwrap(); // this is fine

    let o2: Option<i32> = None;
    o2.unwrap(); // this panics!
}
#+end_src

TODO: See my OCamlCheatSheet on ‚Äòoption‚Äô


** reads!
:PROPERTIES:
:CUSTOM_ID: reads
:END:


[[https://doc.rust-lang.org/rust-by-example/std/option.html][Option - Rust By Example]]


[[https://8thlight.com/blog/uku-taht/2015/04/29/using-the-option-type-effectively.html][Using The Option Type Effectively | 8th Light]]

[[https://www.ameyalokare.com/rust/2017/10/23/rust-options.html][Rust: Using Options by example]]

[[http://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/std/option/index.html][std::option - Rust]] :fire:
[[https://doc.rust-lang.org/std/option/][std::option a la Rust]]

[[https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then][Option in std::option - Rust]]

* TODO COMMENT Enums ~ Result is also an enum, it can either contain something, or an error:
:PROPERTIES:
:CUSTOM_ID: COMMENT-Enums-Result-is-also-an-enum-it-can-either-contain-something-or-an-error
:END:

Haskell's Either type

#+begin_src rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+end_src

It also panics when unwrapped and containing an error.

[[https://learning-rust.github.io/docs/e3.option_and_result.html][Option and Result | Learning Rust]]

https://learning-rust.github.io/docs/e3.option_and_result.html
TODO:
[[http://saidvandeklundert.net/learn/2021-09-01-rust-option-and-result/][Rust Option and Result]]

[[https://hamatti.org/posts/learning-rust-2-option-result/][Learning Rust #2: Option & Result : hamatti.org]]

[[https://doc.rust-lang.org/rust-by-example/error/option_unwrap/and_then.html][Combinators: and_then - Rust By Example]]

[[https://doc.rust-lang.org/stable/std/result/enum.Result.html][Result in std::result - Rust]]

** Functions that can fail typically return a Result:
:PROPERTIES:
:CUSTOM_ID: Functions-that-can-fail-typically-return-a-Result
:END:

#+begin_src rust
fn main() {
    let s = std::str::from_utf8(&[240, 159, 141, 137]);
    println!("{:?}", s);
    // prints: Ok("üçâ")

    let s = std::str::from_utf8(&[195, 40]);
    println!("{:?}", s);
    // prints: Err(Utf8Error { valid_up_to: 0, error_len: Some(1) })
}
#+end_src

** If you want to panic in case of failure, you can .unwrap():
:PROPERTIES:
:CUSTOM_ID: If-you-want-to-panic-in-case-of-failure-you-can-unwrap
:END:

#+begin_src rust
fn main() {
    let s = std::str::from_utf8(&[240, 159, 141, 137]).unwrap();
    println!("{:?}", s);
    // prints: "üçâ"

    let s = std::str::from_utf8(&[195, 40]).unwrap();
    // prints: thread 'main' panicked at 'called `Result::unwrap()`
    // on an `Err` value: Utf8Error { valid_up_to: 0, error_len: Some(1) }',
    // src/libcore/result.rs:1165:5
}
#+end_src

Or .expect(), for a custom message:
#+begin_src rust
fn main() {
    let s = std::str::from_utf8(&[195, 40]).expect("valid utf-8");
    // prints: thread 'main' panicked at 'valid utf-8: Utf8Error
    // { valid_up_to: 0, error_len: Some(1) }', src/libcore/result.rs:1165:5
}
#+end_src

** Or, you can match:
:PROPERTIES:
:CUSTOM_ID: Or-you-can-match
:END:

#+begin_src rust
fn main() {
    match std::str::from_utf8(&[240, 159, 141, 137]) {
        Ok(s) => println!("{}", s),
        Err(e) => panic!(e),
    }
    // prints üçâ
}
#+end_src

** Or you can ~if let~
:PROPERTIES:
:CUSTOM_ID: Or-you-can-if-let
:END:

#+begin_src rust
fn main() {
    if let Ok(s) = std::str::from_utf8(&[240, 159, 141, 137]) {
        println!("{}", s);
    }
    // prints üçâ
}
#+end_src

** Or you can bubble up the error:
:PROPERTIES:
:CUSTOM_ID: Or-you-can-bubble-up-the-error
:END:

#+begin_src rust
fn main() -> Result<(), std::str::Utf8Error> {
    match std::str::from_utf8(&[240, 159, 141, 137]) {
        Ok(s) => println!("{}", s),
        Err(e) => return Err(e),
    }
    Ok(())
}
#+end_src

** Or you can use ~?~ to do it the concise way:
:PROPERTIES:
:CUSTOM_ID: Or-you-can-use-to-do-it-the-concise-way
:END:

#+begin_src rust
fn main() -> Result<(), std::str::Utf8Error> {
    let s = std::str::from_utf8(&[240, 159, 141, 137])?;
    println!("{}", s);
    Ok(())
}
#+end_src


** Exercise: Convert an Option<Result<X,Y>> into an Option<X>
:PROPERTIES:
:CUSTOM_ID: Exercise-Convert-an-Option-Result-X-Y-into-an-Option-X
:END:

You can use monads here to reduce the verbosity; namely the [[https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then][and_then]] function and the [[https://learning-rust.github.io/docs/e3.option_and_result.html][ok() function.]]



#+begin_src rust
    let it: Option<Result<i32, i32>> = None; // Some(Ok::<i32, i32>(3));

    let result_id_final = match it {
        Some(Ok(uuid)) => Some(uuid),
        _ => None,
    };

    let result_id_final2 = it.and_then(Result::ok);

    println!("{:?}", result_id_final);
    println!("{:?}", result_id_final2)
}
#+end_src

* TODO COMMENT Closures are just functions of type Fn, FnMut or FnOnce with some captured context.
:PROPERTIES:
:CUSTOM_ID: COMMENT-Closures-are-just-functions-of-type-Fn-FnMut-or-FnOnce-with-some-captured-context
:END:

Their parameters are a comma-separated list of names within a pair of pipes
(|). They don't need curly braces, unless you want to have multiple statements.

#+begin_src rust
fn for_each_planet<F>(f: F)
    where F: Fn(&'static str)
{
    f("Earth");
    f("Mars");
    f("Jupiter");
}

fn main() {
    for_each_planet(|planet| println!("Hello, {}", planet));
}

// prints:
// Hello, Earth
// Hello, Mars
// Hello, Jupiter
#+end_src

** You can return a closure from a function:
:PROPERTIES:
:CUSTOM_ID: You-can-return-a-closure-from-a-function
:END:

#+begin_src rust
fn make_tester(answer: String) -> impl Fn(&str) -> bool {
    move |challenge| {
        challenge == answer
    }
}

fn main() {
    // you can use `.into()` to perform conversions
    // between various types, here `&'static str` and `String`
    let test = make_tester("hunter2".into());
    println!("{}", test("******"));
    println!("{}", test("hunter2"));

}
#+end_src

** You can even move a reference to some of a function's arguments, into a closure it returns:
:PROPERTIES:
:CUSTOM_ID: You-can-even-move-a-reference-to-some-of-a-function's-arguments-into-a-closure-it-returns
:END:

#+begin_src rust
fn make_tester<'a>(answer: &'a str) -> impl Fn(&str) -> bool + 'a {
    move |challenge| {
        challenge == answer
    }
}

fn main() {
    let test = make_tester("hunter2");
    println!("{}", test("*******"));
    println!("{}", test("hunter2"));
}

// output:
// false
// true
#+end_src

Or, with elided lifetimes:

#+begin_src rust
fn make_tester(answer: &str) -> impl Fn(&str) -> bool + '_ {
    move |challenge| {
        challenge == answer
    }
}
#+end_src

* TODO COMMENT Traits and Overloading
:PROPERTIES:
:CUSTOM_ID: COMMENT-Traits-and-Overloading
:END:

/Overloading/ is using the same name to designate operations ‚Äúof the same nature‚Äù
on values of different types.

TODO: Motivating example, how to_string something and have it format! andprintln! nicely?
https://loige.co/how-to-to-string-in-rust#the-display-trait



/Traits/ are something multiple types can have in common:

#+begin_src rust
trait Signed {
    fn is_strictly_negative(self) -> bool;
}
#+end_src

You can implement:

- one of your traits on anyone's type
- anyone's trait on one of your types
- but not a foreign trait on a foreign type

These are called the "orphan rules".

** Number Type ~ Running Example
:PROPERTIES:
:CUSTOM_ID: Number-Type-Running-Example
:END:
#+begin_src rust
struct Number { odd: bool, value: i32 }

fn main() {
    let mut n = Number {
        odd: true,
        value: 17,
    };
    n.value = 19; // all good
}
#+end_src
** Here's an implementation of our trait on our type:
:PROPERTIES:
:CUSTOM_ID: Here's-an-implementation-of-our-trait-on-our-type
:END:

#+begin_src rust
struct Number { odd: bool, value: i32 }

impl Signed for Number {
    fn is_strictly_negative(self) -> bool {
        self.value < 0
    }
}

fn main() {
    let n = Number { odd: false, value: -44 };
    println!("{}", n.is_strictly_negative()); // prints "true"
}
#+end_src

** Our trait on a foreign type (a primitive type, even):
:PROPERTIES:
:CUSTOM_ID: Our-trait-on-a-foreign-type-a-primitive-type-even
:END:

#+begin_src rust
impl Signed for i32 {
    fn is_strictly_negative(self) -> bool {
        self < 0
    }
}

fn main() {
    let n: i32 = -44;
    println!("{}", n.is_strictly_negative()); // prints "true"
}
#+end_src

** A foreign trait on our type:
:PROPERTIES:
:CUSTOM_ID: A-foreign-trait-on-our-type
:END:

#+begin_src rust
// the `Neg` trait is used to overload `-`, the
// unary minus operator.
impl std::ops::Neg for Number {
    type Output = Number;

    fn neg(self) -> Number {
        Number {
            value: -self.value,
            odd: self.odd,
        }
    }
}

fn main() {
    let n = Number { odd: true, value: 987 };
    let m = -n; // this is only possible because we implemented `Neg`
    println!("{}", m.value); // prints "-987"
}
#+end_src

An impl block is always for a type, so, inside that block, Self means that type:
#+begin_src rust
impl std::ops::Neg for Number {
    type Output = Self;

    fn neg(self) -> Self {
        Self {
            value: -self.value,
            odd: self.odd,
        }
    }
}
#+end_src

** Some traits are markers - they don't say that a type implements some methods, they say that certain things can be done with a type.
:PROPERTIES:
:CUSTOM_ID: Some-traits-are-markers-they-don't-say-that-a-type-implements-some-methods-they-say-that-certain-things-can-be-done-with-a-type
:END:

For example, i32 implements trait Copy (in short, i32 is Copy), so this works:

#+begin_src rust
fn main() {
    let a: i32 = 15;
    let b = a; // `a` is copied
    let c = a; // `a` is copied again
}
#+end_src

And this also works:
#+begin_src rust
fn print_i32(x: i32) {
    println!("x = {}", x);
}

fn main() {
    let a: i32 = 15;
    print_i32(a); // `a` is copied
    print_i32(a); // `a` is copied again
}
#+end_src

But the Number struct is not Copy, so this doesn't work:
#+begin_src rust

fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n; // `n` is moved into `m`
    let o = n; // error: use of moved value: `n`
}
#+end_src

And neither does this:

#+begin_src rust
fn print_number(n: Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    let n = Number { odd: true, value: 51 };
    print_number(n); // `n` is moved
    print_number(n); // error: use of moved value: `n`
}
#+end_src

But it works if print_number takes an immutable reference instead:

#+begin_src rust

fn print_number(n: &Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    let n = Number { odd: true, value: 51 };
    print_number(&n); // `n` is borrowed for the time of the call
    print_number(&n); // `n` is borrowed again
}
#+end_src

It also works if a function takes a mutable reference - but only if our variable binding is also mut.

#+begin_src rust
fn invert(n: &mut Number) {
    n.value = -n.value;
}

fn print_number(n: &Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    // this time, `n` is mutable
    let mut n = Number { odd: true, value: 51 };
    print_number(&n);
    invert(&mut n); // `n is borrowed mutably - everything is explicit
    print_number(&n);
}
#+end_src

Trait methods can also take self by reference or mutable reference:

#+begin_src rust
impl std::clone::Clone for Number {
    fn clone(&self) -> Self {
        Self { ..*self }
    }
}
#+end_src

When invoking trait methods, the receiver is borrowed implicitly:

#+begin_src rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let mut m = n.clone();
    m.value += 100;

    print_number(&n);
    print_number(&m);
}
#+end_src

To highlight this: these are equivalent:

#+begin_src rust
let m = n.clone();

let m = std::clone::Clone::clone(&n);
#+end_src

** Marker traits like Copy have no methods:
:PROPERTIES:
:CUSTOM_ID: Marker-traits-like-Copy-have-no-methods
:END:

#+begin_src rust
// note: `Copy` requires that `Clone` is implemented too
impl std::clone::Clone for Number {
    fn clone(&self) -> Self {
        Self { ..*self }
    }
}

impl std::marker::Copy for Number {}
#+end_src

Now, Clone can still be used:

#+begin_src rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n.clone();
    let o = n.clone();
}
#+end_src

But Number values will no longer be moved:
#+begin_src rust

fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n; // `m` is a copy of `n`
    let o = n; // same. `n` is neither moved nor borrowed.
}
#+end_src

** Some traits are so common, they can be implemented automatically by using the derive attribute:
:PROPERTIES:
:CUSTOM_ID: Some-traits-are-so-common-they-can-be-implemented-automatically-by-using-the-derive-attribute
:END:

#+begin_src rust
#[derive(Clone, Copy)]
struct Number {
    odd: bool,
    value: i32,
}

// this expands to `impl Clone for Number` and `impl Copy for Number` blocks.
#+end_src

* TODO COMMENT [FOR/ITER] Anything that is iterable can be used in a for in loop.
:PROPERTIES:
:CUSTOM_ID: COMMENT-Anything-that-is-iterable-can-be-used-in-a-for-in-loop
:END:

We've just seen a range being used, but it also works with a Vec; or a slice:

#+begin_src rust
fn main() {
    for i in (1..=3).rev() {
        // RANGE
        println!("{}", i)
    }

    for i in vec![52, 49, 21] {
        // VECTOR
        println!("I like the number {}", i);
    }

    for i in &[52, 49, 21] {
        // SLICE
        println!("I like the number {}", i);
    }

    // note: `&str` also has a `.bytes()` iterator.
    // Rust's `char` type is a "Unicode scalar value"
    for c in "rust".chars() {
        println!("Give me a {}", c);
    }

    // Even if the iterator items are filtered and mapped and flattened:
    for c in "SuRPRISE INbOUND"
        .chars()
        .filter(|c| c.is_lowercase())
        .flat_map(|c| c.to_uppercase())
    {
        print!("{}", c);
    }
}
#+end_src

#+RESULTS:
#+begin_example
3
2
1
I like the number 52
I like the number 49
I like the number 21
I like the number 52
I like the number 49
I like the number 21
Give me a r
Give me a u
Give me a s
Give me a t
UB
#+end_example

#+begin_src rust
for (index, item) in slice.iter().enumerate() {
    println!("index: {:?} element {:?}", index, item);
}
#+end_src


Finding values in a slice:

slice.iter().position(|v| v == &120); // None
slice.iter().position(|v| v == &4); // Some(4)

* TODO COMMENT match
:PROPERTIES:
:CUSTOM_ID: COMMENT-match
:END:

#+begin_src rust
    // Ifs and matches are also expressions
    // The {blocks} are part of the if-syntax.
    let condition = true;
    let x = if condition { 1 } else { 3 };
    let x = match condition {
        // This is the same as the ‚Äúif‚Äù above.
        true => 1,
        false => 3,
    };
    println!("{}", x)
#+end_src

A match expression is made up of arms. An arm consists of a pattern and the code that should be run if the value given to the beginning of the match expression fits that arm‚Äôs pattern. Rust takes the value given to match and looks through each arm‚Äôs pattern in turn. The match construct and patterns are powerful features in Rust that let you express a variety of situations your code might encounter and make sure that you handle them all. These features will be covered in detail in Chapter 6 and Chapter 18, respectively.

#+begin_src rust
    let patterns can be used as conditions in if:

    Rust code
    struct Number {
        odd: bool,
        value: i32,
    }

    fn main() {
        let one = Number { odd: true, value: 1 };
        let two = Number { odd: false, value: 2 };
        print_number(one);
        print_number(two);
    }

    fn print_number(n: Number) {
        if let Number { odd: true, value } = n {
            println!("Odd number: {}", value);
        } else if let Number { odd: false, value } = n {
            println!("Even number: {}", value);
        }
    }

    // this prints:
    // Odd number: 1
    // Even number: 2
    match arms are also patterns, just like if let:

    fn print_number(n: Number) {
        match n {
            Number { odd: true, value } => println!("Odd number: {}", value),
            Number { odd: false, value } => println!("Even number: {}", value),
        }
    }

    // this prints the same as before
    A match has to be exhaustive: at least one arm needs to match.

    fn print_number(n: Number) {
        match n {
            Number { value: 1, .. } => println!("One"),
            Number { value: 2, .. } => println!("Two"),
            Number { value, .. } => println!("{}", value),
            // if that last arm didn't exist, we would get a compile-time error
        }
    }
    If that's hard, _ can be used as a "catch-all" pattern:

    fn print_number(n: Number) {
        match n.value {
            1 => println!("One"),
            2 => println!("Two"),
            _ => println!("{}", n.value),
        }
    }
#+end_src

* TODO COMMENT Macros
:PROPERTIES:
:CUSTOM_ID: COMMENT-Macros
:END:


+ All of name!(), name![] or name!{} invoke a macro. Macros just expand to regular code.
+ In fact, ~println!~ is a macro:

* TODO COMMENT docstrings
:PROPERTIES:
:CUSTOM_ID: COMMENT-docstrings
:END:


The triple slash comment in Rust is meant to be it's version of JSDoc as
well. If you run cargo doc, it will generate HTML documentation of all your code
to the /target/doc folder. Those special doc-comments go into the generated
documentation attached to the code they precede.

More info: https://doc.rust-lang.org/rust-by-example/meta/doc.html

* TODO COMMENT modules
:PROPERTIES:
:CUSTOM_ID: COMMENT-modules
:END:



mod <module_name> tells rust to load and compile that module, and use
<module_path> makes an identifier available within the current
namespace. Putting a pub in front of either of those re-exports those
identifiers.

* TODO COMMENT macros: Removing runtime overhead at compile time.
:PROPERTIES:
:CUSTOM_ID: COMMENT-macros-Removing-runtime-overhead-at-compile-time
:END:

Consider this function and its use:
#+begin_src rust
  fn string_vec(v: &[&str]) -> Vec<String> {
        v.iter().map(|&x| x.into()).collect()
    }
  let mut fields = string_vec(&[
        "ScheduleId",
        "InspectionId",
        "InspectionTypeId",
        "InspectionTypeName",
        "AssetId"])
#+end_src

My hesitation with your suggestion is that your code gains developer readability in exchange for a small reduction in run-time performance speed.

Instead of simple allocation of strings into an array, you'd be allocation an array, allocating an iterator which contains the first array, iterating over that array, and then collection that mapping into a new array.

If we could make a macro instead, I'd definitely use that as a macro must run at
compile-time.

Also nicely done on the utility function! ü¶Ä

My comments are only because the strings are string literals which can be optimized as they are by the compiler.

#+begin_src rust
      /// Convert any number of `&str` into a `Vec<String>`.
      ///
      /// ```
      ///    assert_eq!(
      ///        vec_string!("me", "you", "them"),
      ///        &mut vec!["me".to_string(), "you".to_string(), "them".to_string()]
      ///    );
      ///
      ///    let it = vec_string!("a", "b");
      ///    it.append(vec_string!("c", "d"));
      ///    assert_eq!( it, &mut vec![ "a".to_string(), "b".to_string(), "c".to_string(), "d".to_string() ])
      ///
      /// ```
      macro_rules! vec_string {
          ($($e:expr),*) => {&mut vec![ $( String::from($e) ),*] }
      }
#+end_src

** My first Rust macro
:PROPERTIES:
:CUSTOM_ID: My-first-Rust-macro
:END:

#+begin_src rust

    /// Try to convert any number of `&str` or an `Option::<String>` into a  vec of `String`, defaulting to `""`.
    ///
    /// ```
    ///    assert_eq!(
    ///        vec_string_or_empty!("hola", Some("hi".to_string()), Option::<String>::None),
    ///        &mut vec!["hola", "hi", ""])
    /// ```
    macro_rules! vec_string_or_empty {
        ($($e:expr),*) => {&mut vec![ $(
            if let Some(&s) = (&$e as &dyn Any).downcast_ref::<&str>() {
                String::from(s)
            } else if let Some(o) = (&$e as &dyn Any).downcast_ref::<Option<String>>() {
                String::from(match o {
                    Some(s) => s,
                    None => "",
                })
            } else {
                dbg!("Unexpected item: {:?}", $e);
                String::from("")
            }
        ),*] }
    }
#+end_src

* TODO COMMENT idioms
:PROPERTIES:
:CUSTOM_ID: COMMENT-idioms
:END:

It's a Rust idiom that types are given PascalCase names while identifiers (like
for variables and functions) are in snake_case. If you deviate from that, the
compiler will display warnings about not following that style.

* TODO COMMENT Variance and lifetimes
:PROPERTIES:
:CUSTOM_ID: COMMENT-Variance-and-lifetimes
:END:

The other issue is around lifetimes. The code in your macro is requiring that
the values have a 'static lifetime meaning they must be valid through the whole
lifetime of the application. I tried to removing that variance but didn't have
any luck within a window of time. If interested in further reading
doc.rust-lang.org/nomicon/subtyping.html#variance or watching
youtube.com/watch?v=iVYWDIW71jk (advanced level; highly recommend this video for
anyone brave enough to go that deep into the language).

* TODO COMMENT Understanding Ownership
:PROPERTIES:
:CUSTOM_ID: COMMENT-Understanding-Ownership
:END:

Ownership is Rust‚Äôs most unique feature, and it enables Rust to make memory
safety guarantees without needing a garbage collector. Therefore, it‚Äôs important
to understand how ownership works in Rust. In this chapter, we‚Äôll talk about
ownership as well as several related features: borrowing, slices, and how Rust
lays data out in memory.

*my/doc/garbage-collection* All programs have to manage the way they use a
computer‚Äôs memory while running. Some languages have garbage collection that
constantly looks for no longer used memory as the program runs; in other
languages, the programmer must explicitly allocate and free the memory. Rust
uses a third approach: memory is managed through a system of ownership with a
set of rules that the compiler checks at compile time. None of the ownership
features slow down your program while it‚Äôs running.

*Ownership Rules*
+ Each value in Rust has a variable that‚Äôs called its owner.
+ There can only be one owner at a time.
+ When the owner goes out of scope, the value will be [[https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop][dropped]] (‚Äúit's memory is
  garbage collected‚Äù).

We‚Äôve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they aren‚Äôt suitable for every
situation in which we may want to use text. One reason is that they‚Äôre
immutable. Another is that not every string value can be known when we write our
code: for example, what if we want to take user input and store it? For these
situations, Rust has a second string type, String. This type is allocated on the
heap and as such is able to store an amount of text that is unknown to us at
compile time. You can create a String from a string literal using the from
function, like so:
+ let s = String::from("hello");

#+begin_src rust
fn main() {
    let mut s = String::from("hello");
    s.push_str(", world!"); // push_str() appends a literal to a String
    assert!(s == "hello, world!")
}
#+end_src

Just as ~let mut x = 12~ means we can later declare ~x = 13~, the /variable is
mutable/ but we did not change the literal ‚Äú12‚Äù.  Likewise, ~str~ are values that
cannot be changed and are constructed by writing ~"~ then any text then ~"~; that is
all. (Other languages call these ‚Äòsymbols‚Äô.)

For scalar variables ~x~ and ~y~, the declaration ~x = y~ means ‚Äúcopy the value of ~y~
and stick it in ~x~.‚Äù For compound structures, ~x = y~ means ‚Äúsince there can only
be one owner, make ~x~ refer to the object that ~y~ refereed to, and make ~y~ refer to
nothing‚Äù, and one says ‚Äú[the object pointed to by] y has *moved* to x‚Äù ---use of ~y~
is now a compile-time error.  Copying is very expensive for objects, and sharing
an object via two aliases can be confusing, so ownership is changed instead.  If
you really do want to (deeply) copy an object: ~x = y.clone()~.

Tuples/arrays of scalars /copy/, but tuples/arrays involving non-scalars /move/.

*Ownership and Functions.* Passing a variable to a function will move or copy,
just as assignment does.  That is, ~f(x)~ will take ownership if ~x~ is a variable ~x~
of a compound type, and otherwise a copy of ~x~ is performed.  In particular,
~f(x); x~ will result in an error for compound ~x~, since ~x~'s object /moved/ when ~f~
was called and now ~x~ is invalid for use. In contrast, ~ok~ below takes ownership
of ~b~ but then returns ownership to (a shadowing of) ~b~.
#+begin_src rust
// Three ways to get the length of a string
fn main() {
    let a = String::from("a"); theft(a); // assert!(a == "a"); // Error!
    let b = String::from("b"); let (b, _) = akward(b); assert!(b == "b"); // Okay
    let c = String::from("c"); let n = best(&c); assert!(c.len() == n); // Yay!
}

fn theft(a : String) -> usize { a.len() }
fn akward(b : String) -> (String, usize) { let n = b.len(); (b, n) }
fn best(c : &String) -> usize {c.len()}
#+end_src

Taking ownership and then returning ownership with every function is a bit
tedious. What if we want to let a function use a value but not take ownership?
It‚Äôs quite annoying that anything we pass in also needs to be passed back if we
want to use it again, in addition to any data resulting from the body of the
function that we might want to return as well. Enter *references*: Method ~count~
wants to refer to a ~String~ /without/ taking ownership, and so the method call
expects a reference, which are constructed with ~&~.

Notice that in the body of ~best~, we use the argument as if it were a normal
~String~.

We call having references as function parameters *borrowing*. As in real life, if
a person owns something, you can borrow it from them. When you‚Äôre done, you have
to give it back.

Just as variables are immutable by default, so are references. We‚Äôre not allowed to modify something we have a reference to.

#+begin_src rust
fn main() {
    let a = String::from("a"); let b = &a; let _c = &a; assert!(b == "a"); // OK
    // Mutable variables cannot be borrowed more than once
    // let mut x = String::from("a"); let y = &mut x; let z = &mut x; assert!(y == z); // Crash!

    println!("{:?}", b);
}

#+end_src

Mutable references can only be made from mutable variables.


--------------------------------------------------------------------------------

As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not simultaneous ones:


#+begin_src rust
    let mut s = String::from("hello");

    {
        let r1 = &mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &mut s;
#+end_src

--------------------------------------------------------------------------------

We also cannot have a mutable reference while we have an immutable one. Users of
an immutable reference don‚Äôt expect the values to suddenly change out from under
them! However, multiple immutable references are okay because no one who is just
reading the data has the ability to affect anyone else‚Äôs reading of the data.

#+begin_src rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM

    println!("{}, {}, and {}", r1, r2, r3);
}
#+end_src

--------------------------------------------------------------------------------

Note that a reference‚Äôs scope starts from where it is introduced and continues through the last time that reference is used. For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:

#+begin_src rust
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    println!("{} and {}", r1, r2);
    // r1 and r2 are no longer used after this point

    let r3 = &mut s; // no problem
    println!("{}", r3);
#+end_src

    The scopes of the immutable references r1 and r2 end after the println! where
    they are last used, which is before the mutable reference r3 is
    created. These scopes don‚Äôt overlap, so this code is allowed.

--------------------------------------------------------------------------------

Rust [[https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#dangling-references][prevents dangling pointers]].

--------------------------------------------------------------------------------

The Rules of References
Let‚Äôs recap what we‚Äôve discussed about references:

- At any given time, you can have either one mutable reference or any number of immutable references.
- References must always be valid.

Next, we‚Äôll look at a different kind of reference: slices.

* TODO COMMENT Enums ---‚ÄúScenarios with payloads‚Äù
:PROPERTIES:
:CUSTOM_ID: COMMENT-Enums-Scenarios-with-payloads
:END:

With src_rust[:exports code]{enum}s we can model a problem in terms of its
possible allowable scenarios ---e.g., whether a resulting computation is
src_rust[:exports code]{ok(x)} with a meaningful value ~x~, or if it is
src_rust[:exports code]{Err} since the computation failed somehow.

* TODO COMMENT Strings
:PROPERTIES:
:CUSTOM_ID: COMMENT-Strings
:END:

Akin to ~[œÑ]~ and ~Vec<œÑ>~, we have ~str~ and ~String~.

+ ~str~ ‚áí String literals, not growable nor alterable.
+ ~String~ ‚áí String objects, that can grow and be altered.

#+begin_src rust
fn main () {


    let mut s = String::from("Hello, Rust!");
println!("{} and {}", s.capacity(), s.len()); // prints 12
s.push_str("Here I come!");
println!("{}", s.len()); // prints 24
println!("{}",s);

let s = "Hello, Rust!";
// s.push_str("Here I come!"); // Nope!
println!("{}", s.len()); // prints 12


    let s1 = String::from("hello");
    let s2 = s1;
    let s2 = &s1;
    println!("{:?}, world!", s1);
}
#+end_src
#+RESULTS:

run:rust
* TODO COMMENT Docstrings
:PROPERTIES:
:CUSTOM_ID: COMMENT-Docstrings
:END:

Doc comments which are parsed into HTML library documentation:
/// Generate library docs for the following item.
//! Generate library docs for the enclosing item.

- https://doc.rust-lang.org/rust-by-example/meta/doc.html

#+begin_src rust
/// This says a full name: `first` `last`.
/// Docstrings start with ‚Äú///‚Äù and appear in your editor's tooltips.
///
/// [Emacs] When I start typing and select an option from completion, it becomes
/// a fillable-snippet, TAB to fill the next argument, and the function's
/// docstring is displayed in the minibuffer.
///
/// # Examples
///
/// Basic usage:
///
/// ```
/// // some invalid bytes, in a vector
/// let bytes = vec![0, 159];
/// println!("{}", bytes);
/// assert!(true);
/// ```
/// NOTE: I don't know how to use Run-doctest yet, need to read the rustic manpage
fn say_name(first: String) {
    println!("{}", first)
}
#+end_src

* TODO COMMENT Reading from and writing to files
:PROPERTIES:
:CUSTOM_ID: COMMENT-Reading-from-and-writing-to-files
:END:

#+begin_src rust
fn main() {
    // create the director if needed, ignore errors if already exists
    std::fs::create_dir("./output").ok();

    // load the file input tsv file
    let input_data = std::fs::read_to_string("./data.tsv").unwrap();
    let records : Vec<Vec<&str>> = input_data
        .lines()
        .map(|line| {
            let split_line = line.split('\t').collect::<Vec<_>>();

            // panic if any line has multiple tabs
            assert_eq!(split_line.len(), 2);

            split_line
        })
        .collect();

    // this is used to suffix occurence numbers to the first column to make non-conflicting filenames
    let mut number_suffixes = std::collections::HashMap::new();


    records.iter().for_each(|r| {
        // println!("HI {:?}", r)
    });


    // iterate over records
    for record in records {
        // create or increment the suffix as needed
        *number_suffixes.entry(record[0]).or_insert(0) += 1;

        // write the file
        std::fs::write(
            format!(
                "./output/{}_{}.json",
                record[0],
                number_suffixes.get(record[0]).unwrap()
            ),
            record[1],
        );
        println!("HI {:?} {}", record[0], number_suffixes.get(record[0]).unwrap())
    }
}
#+end_src

* TODO COMMENT Branching / match
:PROPERTIES:
:CUSTOM_ID: COMMENT-Branching
:END:


#+begin_src rust
fn main() {
    let b = if 0 < 1 { true } else { false };
    assert!(b == (0 < 1));

    let it = 3;
    let res = match it {
        1 => 'a',
        2 => 'b',
        3 => 'c',
        _ => 'd', // default case
    };
    assert!(res == 'c')
}
#+end_src

** Control flow
:PROPERTIES:
:CUSTOM_ID: Control-flow
:END:
 + ~if~ can be used without an ~else~ but must uses {braces} for the branches.
   - The condition /must/ be a ~bool~.
   - When used as an expression, the bodies must have the same type.
     - ~let number = if condition { 5 } else { "six" };~ crashes since no type
       can be assigned to ~number~ /at compile time/.
   - Avoid nested ~else if~'s by using a ~match~ instead.
 + Rust has three kinds of loops: ~loop~, ~while~, and ~for~. Let‚Äôs try each one.
 + The ~loop~ keyword tells Rust to execute a block of code over and over again
   forever or until you explicitly tell it to stop.
   - You can place the ~break~ keyword within the loop to tell the program when to stop executing the loop.
   - When ~loop~ is used as an /expression/, say in a ~let~, then ~break~ returns the
     result of the loop: ~let x = loop { ‚ãØ; break expr; ‚ãØ}~.
   - ~while cond {‚ãØ} ‚âà loop {‚ãØ; if ! cond {break;}}~
   - Loop through a collection with ~for~.
 #+begin_src rust
fn main() {
    let xs = [10, 20, 30, 40, 50];
    for i in 0..xs.len()-1 { println!("{}", xs[i]) }
    // Better:
    for x in xs.iter() { println!("{}", x) }
}
 #+end_src

* TODO COMMENT [String] Slices
:PROPERTIES:
:CUSTOM_ID: COMMENT-Slices
:END:

Suppose we're looking for the first ‚Äúhello‚Äù in a string.  If we use an index,
then we have to keep the string and the index variable in-sync: Whenever the
string changes, we must change the index variable. This is tedious and error
prone. A better solution is /immutable string slices/: If we have an immutable
reference to that part of the string, then by Rust's ownership rules, the string
cannot be altered there.

A string slice is a reference to part of a String, and it looks like this:


#+begin_src rust
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
#+end_src

    This is similar to taking a reference to the whole String but with the extra
    [0..5] bit. Rather than a reference to the entire String, it‚Äôs a reference
    to a portion of the String.

Slice abbreviations
| ‚Äúup to ùìÉ‚Äù       |   | ~&s[0..ùìÉ]~       | ‚âà | ~&s[..ùìÉ]~ |
| ‚ÄúùìÉ onwards‚Äù     |   | ~&s[ùìÉ..s.len()]~ | ‚âà | ~&s[ùìÉ..]~ |
| ‚Äúall, as slice‚Äù |   | ~&s[0..s.len()]~ | ‚âà | ~&s[..]~  |

The type that signifies ‚Äústring slice‚Äù is written as ~&str~.

--------------------------------------------------------------------------------

String Literals Are Slices

Recall that we talked about string literals being stored inside the binary. Now
that we know about slices, we can properly understand string literals:

#+begin_src rust
let s = "Hello, world!";
#+end_src


The type of s here is &str: it‚Äôs a slice pointing to that specific point of the
binary. This is also why string literals are immutable; &str is an immutable
reference.

--------------------------------------------------------------------------------

When defining ‚Äústring functions‚Äù, it's best to take ~&str~ as parameters since
then such functions will work with string literals (elements of type ~&str~) and
with ~String~ values ~s~ by passing in ~&s[..]~ to convert them to string slices.

String slices, as you might imagine, are specific to strings. But there‚Äôs a more
general slice type, too.  Just as we might want to refer to a part of a string,
we might want to refer to part of an array. We‚Äôd do so like this:
#+begin_src rust
#![allow(unused)]
fn main() {
let array     : [i32; 5]  = [1, 2, 3, 4, 5];
let reference : &[i32;5]  = &array;
let slice     : &[i32]    = &array[1..3];

let a : &[i32; 5] = &[1, 2, 3, 4 ,5];
let b: &[&str] = &["one", "two", "three"];
// Why is the type of ‚Äúa‚Äù not ‚Äú&[i32]‚Äù?
}
#+end_src

Slices are a view into a block of memory represented as a pointer and a length.

# ·Éö(‡≤†Áõä‡≤†)·Éö

#+begin_src rust
fn main () {
    // Explicitly mention sizes of slices
    let a: &[i32; 5]  = &[1, 2, 3, 4, 5];
    let b: &[&str; 3] = &["one", "two", "three"];
    println!("{:?} and {:?}", a, b);

    // Or not, that's okay too
    let x: &[i32] = &[1, 2, 3, 4 ,5];
    let y: &[&str] = &["one", "two", "three"];
    println!("{:?} and {:?}", x, y);

    // Mutable slices
    let m : &mut[i32; 1] = &mut [1];
     m[0] = 7;

    let it = String::from("it");
    steal( it );
    it;
    }
#+end_src

** COMMENT Slices
:PROPERTIES:
:CUSTOM_ID: COMMENT-Slices
:END:

Slices are the answer to ‚ÄúWhat is the input type of a function that consumes
arrays /but/ doesn't know their length?‚Äù Slices act like temporary views into an
array or a vector.
- String world analogy: str is to String, what [T] is to Vec<T>.)
- Slices are views into a list of objects, and have type [T], indicating a slice of objects with type T.

# (This is essentially how variable-size arrays are implemented in C.)
#+begin_src emacs-lisp
// This function borrows a slice
fn analyze_slice(slice: &[i32]) {
    println!("first element of the slice: {}", slice[0]);
    println!("the slice has {} elements", slice.len());
}

fn main() {
    // Fixed-size array (type signature is superfluous)
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    // Arrays can be automatically borrowed as slices
    println!("borrow the whole array as a slice");
    analyze_slice(&xs);

    // Slices can point to a section of an array
    // They are of the form [starting_index..ending_index]
    // starting_index is the first position in the slice
    // ending_index is one more than the last position in the slice
    println!("borrow a section of the array as a slice");
    analyze_slice(&ys[1 .. 4]);

    // Out of bound indexing causes compile error
    println!("{}", xs[5]);
}
#+end_src

Slices act like temporary views into an array or a vector. For example if you have an array:

let arr: [i32; 4] = [10, 20, 30, 40];
You can create a slice containing second and third elements like this:

let s = &arr[1..3];
The [1..3] syntax creates a range from index 1 (inclusive) to 3 (exclusive). If you omit the first number in the range ([..3]) it defaults to zero and if you omit the last number ([1..]) it defaults to the length of the array. If you print the elements in the [1..3] slice, you get 20 and 30:

//prints 20
println!("First element in slice: {:}", s[0]);
//prints 30
println!("Second element in slice: {:}", s[1]);
But if you try to access an element outside the range of the slice, it will panic:

//panics: index out of bounds
println!("Third element in slice: {:}", s[2]);
But how does the slice know that it has only two elements? That's because a slice is not simply a pointer to the array, it also carries around the number of elements of the slice in an additional length field.

Since slices borrow from the underlying data structure, all the usual borrowing rules apply. For example, this code is rejected by the compiler:

fn main() {
    let mut v: Vec<i32> = vec![1, 2, 3, 4];
    let s = &v[..];
    v.push(5);
    println!("First element in slice: {:}", s[0]);
}
Why? Because when the slice is created, it points to the first element of the vector's backing buffer and as a new element is pushed onto the vector, it allocates a new buffer and the old buffer is deallocated. This leaves the slice pointing to an invalid memory address, which if accessed would have lead to undefined behaviour. Rust has saved you from disaster again.

NOTE
Since slices can be created from both arrays and vectors, they are a very powerful abstraction. Hence for arguments in functions, the default choice should be to accept a slice instead of an array or a vector. In fact many functions like len, is_empty etc. work on slices instead of on vectors or arrays.


TODO: Difference between &[T] and Vec<T>  and: &[char] and &str ?

| Type   | Growable | Owned | Dropped when out of scope? |
|--------+----------+-------+----------------------------|
| Vec<T> | ‚úì        | ‚úî     | ‚úî                          |
| &[T]   | √ó        | √ó     | √ó                          |
|        |          |       |                            |

* TODO COMMENT for (i, &item) in bytes.iter().enumerate()
:PROPERTIES:
:CUSTOM_ID: COMMENT-for-i-item-in-bytes-iter-enumerate
:END:
We‚Äôll discuss iterators in more detail in Chapter 13. For now, know that iter is a method that returns each element in a collection and that enumerate wraps the result of iter and returns each element as part of a tuple instead. The first element of the tuple returned from enumerate is the index, and the second element is a reference to the element. This is a bit more convenient than calculating the index ourselves.

Because the enumerate method returns a tuple, we can use patterns to destructure that tuple, just like everywhere else in Rust. So in the for loop, we specify a pattern that has i for the index in the tuple and &item for the single byte in the tuple. Because we get a reference to the element from .iter().enumerate(), we use & in the pattern.
* TODO COMMENT Testing
:PROPERTIES:
:CUSTOM_ID: COMMENT-Testing
:END:
+ ~cargo test~ to run all functions with a #[test] marker above them.
+ Do ~cargo test > test.out~ to get a nice output listing the success/failures.

#+begin_src rust
#[test]
fn super_simple_test () {
   assert!(fib(1) == 1);
}

#[test]
fn super_simple_test_two () {
   assert!(fib(10) == 89);
}

#[test]
fn super_simple_test_third () {
   assert!(fib(8) == 34);
}

fn fib (n : i64) -> i64 {
    if n <= 1 { 1 }
    else { fib(n - 1) + fib (n - 2) }
}

fn main() {
    println!("fib ‚áí {}", fib(6));




}
#+end_src

1, 1, 2, 3, 5, 8, 13, 21

* TODO COMMENT On ‚Äú::‚Äù
:PROPERTIES:
:CUSTOM_ID: COMMENT-On
:END:

  The :: syntax in the ::new line indicates that new is an associated function of the String type. An associated function is implemented on a type, in this case String, rather than on a particular instance of a String. Some languages call this a static method.

This new function creates a new, empty string. You‚Äôll find a new function on many types, because it‚Äôs a common name for a function that makes a new value of some kind.

To summarize, the let mut guess = String::new(); line has created a mutable variable that is currently bound to a new, empty instance of a String. Whew!

MA: I.e., new is a factory method.

* TODO COMMENT ref: On ‚Äú&‚Äù
:PROPERTIES:
:CUSTOM_ID: COMMENT-ref-On
:END:

  The & indicates that this argument is a reference, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times. References are a complex feature, and one of Rust‚Äôs major advantages is how safe and easy it is to use references. You don‚Äôt need to know a lot of those details to finish this program. For now, all you need to know is that like variables, references are immutable by default. Hence, you need to write &mut guess rather than &guess to make it mutable. (Chapter 4 will explain references more thoroughly.)
* TODO COMMENT Traits
:PROPERTIES:
:CUSTOM_ID: COMMENT-Traits
:END:



  An impl block is always for a type, so, inside that block, Self means that type:

Some traits are so common, they can be implemented automatically by using the derive attribute:
